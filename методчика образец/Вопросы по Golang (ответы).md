

==============================
    Мапа
==============================
Часто
-------------
  
      -Что такое мапа? 
Мапа (или карта) — это структура данных, которая хранит пары “ключ-значение”. Каждый ключ уникален и используется для доступа к соответствующему значению.

Средне
-------------
     
      -Что произойдет при конкуррентной записи в мапу? 
При конкурентной записи в мапу без должной синхронизации могут возникнуть гонки данных, что приведет к некорректным результатам или повреждению данных.

      -Как устроена мапа под капотом? 
Мапы часто реализуются с использованием хеш-таблиц, где ключи хешируются для определения индекса в массиве, где хранятся значения.

      -Какие ключи могут быть у мапы? 
Ключи могут быть любого типа, который поддерживает операции сравнения и хеширования. В большинстве языков программирования это могут быть строки, числа и другие примитивные типы.

     -Какая сложность работы с мапой? 
В среднем, операции вставки, удаления и поиска в мапе имеют сложность O(1), но в худшем случае (при множественных коллизиях) сложность может достигать O(n).

     -Можно ли взять адрес элемента мапы и почему? 
В большинстве реализаций мап нельзя напрямую взять адрес элемента, так как мапы могут изменять внутреннюю структуру при добавлении или удалении элементов, что делает адреса непостоянными.

     -Как работает эвакуация данных? 
Эвакуация данных (rehashing) происходит, когда мапа перераспределяет элементы в новый массив большего размера, чтобы уменьшить количество коллизий и поддерживать эффективность операций.


Редко
-----------


     -Как разрешаются коллизии в мапе? 
Коллизии разрешаются различными методами, такими как цепочки (chaining) или открытая адресация (open addressing).

     -Как сделать конкурентную запись в мапу? 
Для конкурентной записи используются специальные структуры данных, такие как sync.Map в Go или ConcurrentHashMap в Java, которые обеспечивают потокобезопасность.

     -Как достигается константная сложность работы с мапой? 
Константная сложность достигается за счет использования эффективных хеш-функций и поддержания низкого коэффициента загрузки (load factor).

     -В функции make для мапы мы указываем число. Что оно дает? 
Это число задает начальный размер внутреннего массива мапы, что помогает избежать частых перераспределений при добавлении элементов.

     -Для чего используется мапа? 
Мапы используются для быстрого поиска, вставки и удаления данных по ключу, что делает их полезными в различных приложениях, от кэширования до хранения конфигурационных данных.

     -Мапа потокобезопасная? 
Обычные мапы не потокобезопасны. Для потокобезопасности используются специальные реализации, такие как sync.Map.

     -Пробовали из разных потоков писать в мапу? 
Писать в обычную мапу из разных потоков без синхронизации не рекомендуется из-за риска гонок данных.

     -Стало слишком много коллизий в мапе, как решить проблему? 
Увеличение размера мапы и перераспределение (rehashing) может помочь уменьшить количество коллизий.

     -Какая сложность работы с мапой в худшем случае? 
В худшем случае сложность операций может достигать O(n), особенно если все ключи хешируются в один и тот же индекс.

     -Что произойдет при конкуррентном чтении из мапы? 
Конкуррентное чтение из мапы обычно безопасно, но если одновременно происходят записи, это может привести к некорректным данным.

     -Чем мапа отличается от sync.Map? 
sync.Map в Go специально разработана для безопасного использования в многопоточных средах, обеспечивая атомарные операции и избегая гонок данных.

==============================
    Массивы/Слайсы
==============================
Часто
-------------
     -Что такое слайс? 
Слайс в Go — это динамическая структура данных, которая представляет собой ссылку на массив. Слайсы позволяют работать с подмножествами массивов и могут изменять свою длину.

     -Чем массив отличается от слайса? 
Массивы имеют фиксированную длину, определяемую при создании, и не могут изменяться. Слайсы, напротив, являются динамическими и могут изменять свою длину с помощью встроенных функций, таких как append.


Средне 
-------------
      -Как работает append? 
Функция append добавляет элементы в конец слайса. Если вместимость слайса недостаточна для добавления новых элементов, создается новый массив с увеличенной вместимостью, и элементы копируются в него.


Редко 
------------
      -Как правильно/неправильно работать со слайсом? 
   Правильно:
Использовать append для добавления элементов.
Инициализировать слайсы с помощью make для указания начальной длины и вместимости.
   Неправильно:
Изменять элементы слайса, если он используется в нескольких местах одновременно без синхронизации.

     -Для чего можно использовать массивы в Golang? 
Массивы полезны, когда требуется фиксированная длина и высокая производительность, например, для хранения данных, которые не будут изменяться.

      -До какого размера можно увеличивать слайс? 
Размер слайса ограничен доступной памятью системы.

     -Допустима ли конкурентная работа со слайсом? 
Конкурентная работа со слайсом допустима, но требует синхронизации (например, с помощью мьютексов) для предотвращения гонок данных.

     -Для чего используются слайсы? 
Слайсы используются для работы с динамическими коллекциями данных, где требуется изменяемая длина.

     -Берем от слайса слайс, куда будет указывать его указатель? 
Новый слайс будет указывать на тот же массив, что и исходный, но с другим начальным и конечным индексами.

     -В чем разница между слайсом указателей и слайсом значений с точки зрения вызова функции? 
Слайс указателей передает ссылки на элементы, что позволяет изменять исходные данные. Слайс значений передает копии элементов, что не влияет на исходные данные.

     -Где в памяти размещается массив, а где слайс? 
Массивы размещаются в непрерывной области памяти. Слайсы содержат указатель на массив, длину и вместимость, и могут указывать на любую часть массива.

     -Какие методы оптимизации работы со слайсами ты бы применил в работе?
Инициализация слайсов с достаточной вместимостью.
Использование copy для копирования данных между слайсами.
Какие есть ограничения при работе со слайсом? Основное ограничение — это доступная память системы. Также важно учитывать, что слайсы не могут быть сравнены напрямую, кроме как с nil.

     -Какие есть средства для добавления элементов в слайс? 
Основное средство — это функция append.

     -Какая есть функция для создания слайса с длиной отличной от нуля? 
Функция make позволяет создать слайс с заданной длиной и вместимостью: make([]int, длина, вместимость).

     -С какой скоростью идет поиск в массиве и почему? 
Поиск в массиве имеет линейную сложность O(n), так как в худшем случае требуется проверить каждый элемент.

     -Чем хорош массив по сравнению со слайсом? 
Массивы обеспечивают более высокую производительность и предсказуемость, так как их длина фиксирована и не изменяется.

     -Что такое массив? 
Массив — это коллекция элементов одного типа с фиксированной длиной, определяемой при создании.


==============================
    Каналы
==============================
Часто
-------------
     -Что такое каналы? 
Каналы в Go — это средства коммуникации между горутинами. Они позволяют одной горутине отправлять данные, а другой — получать их, обеспечивая синхронизацию и обмен данными без использования явных блокировок.


Средне
--------------
     -Как устроен канал и как он работает под капотом? 
Каналы в Go представляют собой структуры данных, содержащие буфер для хранения элементов, а также очереди горутин, ожидающих записи или чтения. Когда горутина пытается записать данные в канал, она блокируется до тех пор, пока другая горутина не прочитает эти данные, и наоборот.

     -Какие есть типы каналов в Golang? 
В Go существуют два типа каналов:
Небуферизованные каналы: данные передаются немедленно, и горутина блокируется до тех пор, пока другая горутина не примет данные.
Буферизованные каналы: данные могут быть записаны в буфер, и горутина блокируется только если буфер заполнен.
Что если писать/читать в закрытый канал? Попытка записи в закрытый канал приведет к панике (runtime panic). Чтение из закрытого канала возвращает нулевое значение типа данных канала и признак закрытия канала.


Редко
-----------
     -Что будет при записи в закрытый канал? 
Запись в закрытый канал вызовет панику, что приведет к аварийному завершению программы.

     -Чем отличается запись/чтение в буферизованном и небуферизованном канале? 
В небуферизованном канале запись и чтение блокируются до тех пор, пока другая сторона не выполнит соответствующую операцию. В буферизованном канале запись блокируется только если буфер заполнен, а чтение — если буфер пуст.

     -Что произойдет с читателями/писателями если закрыть канал? 
Если закрыть канал, все горутины, ожидающие записи, вызовут панику. Горутины, ожидающие чтения, получат нулевое значение и признак закрытия канала.

     -Что если закрыть закрытый канал? 
Попытка закрыть уже закрытый канал вызовет панику.

     -Что используется для неблокирующего чтения из канала? 

Для неблокирующего чтения из канала используется оператор select с default веткой.

     -Какие операции есть с каналами? 
Основные операции с каналами включают создание канала (make(chan тип)), запись (chan <- значение), чтение (<- chan), и закрытие канала (close(chan)).

     -Какие параметры могут иметь каналы? 
Каналы могут быть буферизованными или небуферизованными. Буферизованные каналы создаются с указанием размера буфера: make(chan тип, размер).

     -Для чего используется select при работе с каналами? 
Оператор select позволяет горутине ожидать нескольких операций с каналами одновременно, выполняя ту, которая готова первой.

     -Как проверить, что канал закрыт? 
Для проверки закрытия канала используется второй возвращаемый результат при чтении из канала: значение, ок := <- chan, где ок будет false, если канал закрыт.

     -Как сделать канал буферизованным? 
Буферизованный канал создается с указанием размера буфера: make(chan тип, размер).

     -Есть две горутины, одна пишет в небуферизованный, а другая в буферизованный канал, оба не читаются. Что произойдет? 
Горутина, пишущая в небуферизованный канал, заблокируется до тех пор, пока другая горутина не прочитает данные. Горутина, пишущая в буферизованный канал, заблокируется только если буфер заполнен.


==============================
    Примитивы синхронизации
==============================
Часто
-------------
     -Какие примитивы синхронизации есть в Golang? 
В Go доступны следующие примитивы синхронизации:
Mutex (мьютекс) — для взаимного исключения.
RWMutex (чтение-запись мьютекс) — для разделения доступа на чтение и запись.
WaitGroup — для ожидания завершения группы горутин.
Cond (условная переменная) — для уведомления горутин о наступлении определенного события.
Once — для выполнения инициализации только один раз.
Atomic — для атомарных операций над переменными.

Средне 
--------------
     -Чем мьютекс отличается от семафора?
Мьютекс обеспечивает доступ к ресурсу только одной горутине в конкретный момент времени. Он используется для защиты критических секций кода.
Семафор может ограничивать доступ к ресурсу нескольким горутинам одновременно. Он используется для управления доступом к ресурсам с ограниченной емкостью.


Редко 
---------------
     -Чем мьютексы отличаются от атомиков?
Мьютексы блокируют доступ к ресурсу, обеспечивая взаимное исключение.
Атомики позволяют выполнять операции над переменными атомарно, без блокировок, что может быть быстрее, но подходит только для простых операций.

     -Что из пакета sync используешь на практике? 
На практике часто используются Mutex, RWMutex, WaitGroup, и Once для синхронизации горутин и управления доступом к общим ресурсам.

     -Что можно использовать для ожидания выполнения N горутин? 
Для ожидания выполнения N горутин используется WaitGroup.

     -Какие примитивы синхронизации использовал в работе и для чего?
Mutex — для защиты критических секций.
RWMutex — для разделения доступа на чтение и запись.
WaitGroup — для ожидания завершения группы горутин.
Once — для инициализации, которая должна быть выполнена только один раз.

     -Как устроена WaitGroup под капотом и как ее можно реализовать самому? 
WaitGroup использует счетчик и методы Add, Done и Wait для управления ожиданием завершения горутин. Реализация включает в себя использование мьютексов для защиты счетчика и условных переменных для уведомления о завершении.

     -Сколько нужно ядер, чтобы начать использовать sync.Map? 
sync.Map рекомендуется использовать в многопоточных программах, где количество ядер превышает одно, чтобы эффективно использовать параллелизм.

     -Расскажи про sync.Map 
sync.Map — это структура данных, оптимизированная для конкурентного доступа. Она использует внутренние мьютексы и атомарные операции для обеспечения безопасного доступа к данным.

     -Расскажи про пакет sync 
Пакет sync предоставляет примитивы синхронизации, такие как мьютексы, условные переменные, группы ожидания и атомарные операции, для управления конкурентным доступом к ресурсам.

     -Когда нужно использовать Mutex, а когда RWMutex?
Mutex используется, когда требуется исключительный доступ к ресурсу.
RWMutex используется, когда требуется разделение доступа на чтение и запись, позволяя нескольким горутинам читать одновременно, но блокируя запись.

     -Есть общий ресурс. Хотим, чтобы к нему одновременно обращались только N горутин. Как это сделать? 
Для этого можно использовать семафор с начальным значением N2.
Запустим 1000 горутин с инкрементом инта. Получим в конце тысячу? Что делать, чтобы получить тысячу? Без синхронизации результат будет непредсказуемым из-за гонок данных. Для получения правильного результата нужно использовать мьютекс или атомарные операции.

     -Есть глобальная мапа, глобальный мьютекс. Две функции. Одна блокирует мьютекс, а вторая нет. Что произойдет? 
Функция, не блокирующая мьютекс, может вызвать гонки данных, что приведет к некорректному поведению программы.

     -В чем разница между Mutex и RWMutex?
Mutex блокирует доступ к ресурсу для всех горутин.
RWMutex позволяет нескольким горутинам читать ресурс одновременно, но блокирует запись.


==============================
    Горутины
==============================
Часто
-------------
     -Что такое горутина? 
Горутина — это легковесный поток выполнения в Go, который запускается с помощью ключевого слова go перед вызовом функции. Горутины позволяют выполнять функции конкурентно с другими горутинами в одном и том же адресном пространстве.

     -Чем горутина отличается от треда? 
Горутины легче и занимают меньше памяти по сравнению с традиционными потоками (тредами). Они управляются рантаймом Go, а не операционной системой, что делает их более эффективными для параллельного выполнения задач.


Средне
--------------
     -В чем преимущества горутин над тредами?
Легковесность: Горутины потребляют меньше памяти и ресурсов.
Управление: Горутины управляются рантаймом Go, что упрощает их создание и управление.
Масштабируемость: Можно запускать тысячи горутин одновременно без значительного влияния на производительность.

Что есть в Golang для многопоточности? 
В Go для многопоточности используются горутины и каналы. Горутины позволяют выполнять функции параллельно, а 
каналы обеспечивают безопасную передачу данных между горутинами.


Редко
-----------
     -Зачем понадобилось добавлять горутины в Golang? 
Горутины были добавлены для упрощения написания конкурентного кода и эффективного использования многопроцессорных систем. Они позволяют разработчикам легко создавать параллельные программы без сложного управления потоками.

     -Как можно остановить горутину? 
Горутины можно остановить с помощью каналов, передавая сигналы завершения или используя контексты (context.Context), которые позволяют отменять операции.

     -Расскажите про конкуррентность и параллельность в Golang 
Конкуррентность в Go означает выполнение нескольких задач одновременно, но не обязательно параллельно. Параллельность — это выполнение нескольких задач одновременно на разных процессорах. Go поддерживает оба подхода с помощью горутин и каналов.

     -Когда возникает утечка горутины? 
Утечка горутины возникает, когда горутина продолжает работать, но больше не выполняет полезную работу и не может быть завершена. Это может произойти из-за неправильного использования каналов или блокировок.

     -Какие есть способы связи между горутинами, какие плюсы и минусы? 
Основной способ связи между горутинами — это каналы. Плюсы включают безопасную передачу данных и синхронизацию. Минусы могут включать сложность в управлении и отладке при большом количестве горутин.



==============================
    Интерфейсы
==============================
Часто
-------------
     -Что такое интерфейс? 
Интерфейс — это абстрактный тип данных, который определяет набор методов, но не реализует их. В программировании интерфейсы позволяют различным объектам взаимодействовать друг с другом, обеспечивая гибкость и модульность кода.


Средне
-------------
     -Как устроен интерфейс? 
Интерфейс состоит из набора методов, которые должны быть реализованы любым типом, который этот интерфейс “имплементирует”. В Go, например, интерфейс объявляется с помощью ключевого слова interface и содержит сигнатуры методов без их реализации.

     -Для чего используется интерфейс? 
Интерфейсы используются для достижения полиморфизма, что позволяет объектам разных типов обрабатывать одинаковые методы. Это упрощает тестирование, расширяемость и поддержку кода.


Редко
---------------
     -Как ты используешь интерфейс в работе? 
Интерфейсы часто используются для определения контрактов между различными частями системы. Например, в веб-разработке интерфейсы могут определять методы для обработки HTTP-запросов, что позволяет легко заменять или изменять компоненты без изменения остального кода.

     -Как в строготипизированном языке сделать функцию, которая работает с разными типами? 
В строготипизированных языках, таких как Go, для этого используются интерфейсы. Функция может принимать параметр типа интерфейса, что позволяет ей работать с любым типом, который реализует этот интерфейс.

     -Зачем нужен пустой интерфейс? 
Пустой интерфейс (interface{}) в Go может содержать значение любого типа. Это полезно для создания универсальных контейнеров или функций, которые могут работать с любыми типами данных.

     -Есть интерфейс, а есть указатель на структуру, который nil. Кладем указатель в интерфейс. Что если сравнить интерфейс с nil? 
Если интерфейс содержит nil-указатель, сравнение интерфейса с nil вернет false, так как интерфейс сам по себе не является nil. Для проверки, является ли интерфейс nil, нужно использовать специальную проверку.

     -Чем any отличается от пустого интерфейса? 
В Go 1.18 и выше any является синонимом пустого интерфейса (interface{}). Они полностью взаимозаменяемы и используются для обозначения любого типа.

     -Чем пустой интерфейс отличается от пустой структуры? 
Пустой интерфейс (interface{}) может содержать значение любого типа, тогда как пустая структура (struct{}) не содержит данных и используется для создания нулевых значений или для оптимизации памяти.



==============================
    Общее
==============================

Средне
---------------
     -Какие преимущества есть у Golang?
Простота и читаемость: Go имеет лаконичный и понятный синтаксис, что облегчает чтение и написание кода.
Высокая производительность: Go компилируется в машинный код, что обеспечивает высокую скорость выполнения программ.
Поддержка конкурентности: Встроенная поддержка горутин и каналов позволяет легко реализовывать параллельные и асинхронные задачи.
Богатая стандартная библиотека: Go предлагает множество встроенных пакетов для решения различных задач.
Кроссплатформенность: Go позволяет создавать исполняемые файлы для различных операционных систем без необходимости в дополнительных зависимостях.


Редко
--------------
     -Какие основные компоненты библиотеки runtime знаешь?
Горутинный планировщик: Управляет выполнением горутин.
Сборщик мусора: Автоматически освобождает неиспользуемую память.
Профилировщик: Инструменты для анализа производительности и поиска узких мест.

     -Какие недостатки есть у Golang?
Ограниченная поддержка ООП: Нет классов и наследования, что может быть непривычно для разработчиков, привыкших к объектно-ориентированным языкам.
Молодость языка: Меньше библиотек и инструментов по сравнению с более зрелыми языками.
Упрощенная система типов: Меньше возможностей для метапрограммирования и рефлексии.

     -Какие фреймворки знаешь для инициализации приложения?
Gin: Легкий и быстрый фреймворк для создания веб-приложений.
Beego: Полнофункциональный фреймворк с поддержкой MVC.
Echo: Высокопроизводительный фреймворк с минималистичным API.
Revel: Фреймворк для быстрого создания приложений с поддержкой горячей перезагрузки.

     -Какая сортировка используется в Golang? 
Go использует несколько алгоритмов сортировки, включая быструю сортировку (quicksort), сортировку слиянием (mergesort) и пирамидальную сортировку (heapsort), в зависимости от типа данных.

     -Какая последняя версия Golang? 
На данный момент последняя версия Golang — 1.23.2, выпущенная 1 октября 2024 года.



==============================
    Планировщик
==============================

Средне
-------------
     -Как работает планировщик Golang? 
Планировщик Go управляет выполнением горутин, распределяя их по доступным потокам операционной системы. Он использует модель M:N, где M — это количество горутин, а N — количество потоков ОС. Планировщик обеспечивает эффективное использование ресурсов, переключая контекст между горутинами и поддерживая балансировку нагрузки.


Редко
------------
     -Как работает вытесняющая многозадачность? 
Вытесняющая многозадачность позволяет планировщику принудительно прерывать выполнение горутины, чтобы дать возможность другим горутинам получить процессорное время. Это достигается за счет таймеров и прерываний, которые вызывают переключение контекста.

     -За счет чего достигается параллельное выполнение в Golang? 
Параллельное выполнение достигается за счет использования нескольких потоков ОС, на которых планировщик Go распределяет горутины. Это позволяет горутинам выполняться одновременно на разных ядрах процессора.

     -В чем разница между вытесняющим и кооперативным планировщиком?
Вытесняющий планировщик: Принудительно прерывает выполнение задач для переключения контекста.
Кооперативный планировщик: Зависит от задач, которые добровольно уступают управление1.
В планировщике до версии 1.15 какие операции приводят к переключению контекста горутин? До версии 1.15 переключение контекста происходило при системных вызовах, блокировках, а также при выполнении операций ввода-вывода.

     -Можно ли руками переключить контекст горутины? 
В Go нет прямого способа вручную переключить контекст горутины, так как это управляется планировщиком. Однако можно использовать каналы и другие синхронизационные примитивы для управления выполнением горутин.

     -Может ли горутина начать работу на одном P, приостановиться и продолжить работу на другом P? 
Да, горутина может начать выполнение на одном процессоре (P), приостановиться и продолжить выполнение на другом, если это необходимо для балансировки нагрузки.

     -Может ли одна очередь украсть горутины у другой? 
Да, планировщик Go использует стратегию “work stealing”, при которой одна очередь может “украсть” горутины у другой для более равномерного распределения нагрузки.

     -Расскажи про глобальную и локальную очереди
Глобальная очередь: Содержит горутины, которые могут быть выполнены любым процессором.
Локальные очереди: Каждому процессору (P) соответствует своя локальная очередь горутин.

     -Сколько потоков операционной системы мы можем создать? 
Количество потоков ОС, которые может создать Go-программа, ограничено только ресурсами системы и настройками среды выполнения.

     -Какой тип планировщика в Golang? 
Планировщик Go является кооперативным с элементами вытесняющей многозадачности.

     -Какую функцию выполняет планировщик? 
Планировщик управляет распределением горутин по потокам ОС, обеспечивая эффективное использование процессорного времени и ресурсов.

     -Что происходит с горутиной при ее создании? 
При создании горутины она добавляется в очередь выполнения и ожидает назначения на процессор для выполнения.



==============================
    Контекст
==============================
Часто
-------------
     -Для чего используется контекст? 
Контекст в Go используется для управления временем выполнения, отмены и передачи значений между горутинами. Он помогает контролировать выполнение задач, особенно в асинхронных операциях, таких как запросы к внешним сервисам или обработка данных.


Средне
-------------
     -Что такое контекст? 
Контекст в Go — это интерфейс, который несет информацию о дедлайнах, отмене сигналов и других значениях, которые могут быть полезны для горутин. Он позволяет передавать метаданные и сигналы отмены через границы API.


Редко
-------------

     -Как работает WithCancel? 
context.WithCancel создает новый контекст, который можно отменить вручную. Когда вызывается функция отмены, все горутины, использующие этот контекст, получают сигнал об отмене и могут завершить выполнение.

     -Как применяешь контекст в работе? 
Контекст часто используется для управления временем выполнения запросов к базам данных, внешним API и других длительных операций. Например, можно задать тайм-аут для HTTP-запроса, чтобы избежать бесконечного ожидания ответа.

     -Как устроен контекст? 
Контекст в Go реализован как дерево, где каждый новый контекст создается на основе родительского. Это позволяет легко управлять временем выполнения и отменой для группы связанных операций1.

     -Какие есть виды контекстов?
context.Background(): Используется как корневой контекст для всех других контекстов.
context.TODO(): Используется, когда контекст еще не определен.
context.WithCancel(parent): Создает контекст, который можно отменить вручную.
context.WithDeadline(parent, deadline): Создает контекст с заданным временем завершения.
context.WithTimeout(parent, timeout): Создает контекст с тайм-аутом1.

     -Перекидывали логгер в контексте? 
Да, логгер можно передавать через контекст, чтобы обеспечить доступ к нему в разных частях приложения. Это удобно для централизованного логирования и отслеживания выполнения операций.



==============================
    defer
==============================
Часто
-------------
     -Что такое defer? 
defer — это ключевое слово в Go, которое откладывает выполнение функции до тех пор, пока не завершится выполнение окружающей функции. Это позволяет гарантировать выполнение определенных действий, таких как освобождение ресурсов, независимо от того, как завершится функция.


Средне
------------

     -Для чего используется defer? 
defer используется для выполнения завершающих операций, таких как закрытие файлов, освобождение памяти или завершение сетевых соединений. Это помогает сделать код чище и уменьшить вероятность ошибок, так как завершающие операции находятся рядом с операциями инициализации.

     -Какой порядок выполнения нескольких defer? 
Если в функции используется несколько defer, они выполняются в обратном порядке их объявления (LIFO — Last In, First Out). То есть, последний defer будет выполнен первым.


Редко
-------------
     -Код в defer выполняется до return или после? 
Код в defer выполняется после оператора return, но до фактического возврата значения из функции. Это позволяет гарантировать выполнение завершающих операций даже если функция завершится с ошибкой.

     -Где инициализируется defer, в стеке или куче? 
defer инициализируется в стеке. Вызовы функций, отложенные с помощью defer, добавляются в стек и выполняются при выходе из функции.



==============================
    Память
==============================

Редко
-------------
     -В одном случае ты передаешь указатель на допустим инт, а в другом случае большую структурку. Как с точки зрения рантайма и потребления ресурсов будет вести приложение? 
Передача указателя на int будет более эффективной с точки зрения потребления памяти и производительности, так как указатель занимает меньше места и требует меньше операций копирования. Передача большой структуры по значению может привести к значительным затратам на копирование данных.

     -Как узнать где выделяется переменная, в стеке или куче? 
Go использует анализ побегов (escape analysis) для определения, где должна быть выделена переменная. Если переменная “убегает” из области видимости функции, она будет выделена в куче. В противном случае она будет выделена в стеке.

     -Как можно обнаружить чересчур большое выделение памяти? 
Для обнаружения избыточного выделения памяти можно использовать профилировщики, такие как pprof, которые позволяют анализировать использование памяти и выявлять узкие места.

     -Предположим есть рекурсивная функция. Вызывается много раз. Что может произойти? 
Если рекурсивная функция вызывается много раз без базового случая для завершения, это может привести к переполнению стека (stack overflow), что вызовет аварийное завершение программы.

     -Расскажи про модель памяти в Golang, про стек и про кучу
Стек: Используется для хранения локальных переменных и вызовов функций. Выделение и освобождение памяти в стеке происходит быстро и автоматически.
Куча: Используется для динамического выделения памяти, например, для структур и срезов. Память в куче управляется сборщиком мусора (GC).

     -Какое максимальный размер значения для размещения в стеке? 
Максимальный размер значения для размещения в стеке зависит от конкретной реализации и настроек среды выполнения, но обычно это несколько килобайт.

     -Что такое Escape Analysis? 
Escape Analysis — это процесс, используемый компилятором Go для определения, должна ли переменная быть выделена в стеке или куче. Если переменная “убегает” из области видимости функции, она будет выделена в куче.

     -Что если при увеличении слайса полностью забьем память? 
Если при увеличении слайса будет исчерпана доступная память, программа может вызвать панику из-за недостатка памяти (out of memory) и аварийно завершиться.

     -Что быстрее, размещение объектов в стеке или куче и почему? 
Размещение объектов в стеке быстрее, так как стек управляется автоматически и не требует сложных операций управления памятью, таких как сборка мусора, которая используется для управления кучей.

     -Что такое утечка памяти?
Утечка памяти происходит, когда программа продолжает удерживать ссылки на объекты, которые больше не нужны, что предотвращает их освобождение сборщиком мусора.

     -Что такое стек? 
Стек — это структура данных, используемая для хранения информации о вызовах функций и локальных переменных. Он работает по принципу LIFO (Last In, First Out), что означает, что последний добавленный элемент будет первым удален.



==============================
    Типы данных
==============================

Средне
----------------
     -Какие типы данных есть в Golang?
Целочисленные типы: int8, int16, int32, int64, uint8, uint16, uint32, uint64, int, uint, byte (синоним uint8), rune (синоним int32).
Числа с плавающей точкой: float32, float64.
Комплексные числа: complex64, complex128.
Строки и символы: string, rune.
Булевы значения: bool.
Другие: массивы, срезы, карты, структуры, интерфейсы, каналы.


Редко
---------------
     -Какой длины руна?
Руна в Golang занимает 4 байта (32 бита).

     -Как реализовать Enum в Golang?
В Golang можно использовать константы и типы для создания Enum. Пример:
type Season int
const (
    Summer Season = iota
    Autumn
    Winter
    Spring
).

     -Если нужно в строке хранить эмодзи, то как это сделать?
Эмодзи можно хранить в строках, так как строки в Golang поддерживают UTF-8. Для работы с эмодзи можно использовать пакет gomoji.

     -Что если во время компиляции переполним тип? 
В int8 запишем 256?
Компилятор выдаст ошибку переполнения, так как значение 256 выходит за пределы допустимого диапазона для int8.

     -Что происходит при переполнении числа, например в uint8 выйдем за границу на 1?
При переполнении числа в uint8, значение “обернется” и начнется с 0. Например, 255 + 1 станет 0.


==============================
    Гонка данных
==============================

Средне
-------------
     -Что такое race condition? 
Race condition (гонка данных) возникает, когда две или более горутины одновременно обращаются к одной и той же переменной, и хотя бы одна из них выполняет запись. Это может привести к непредсказуемому поведению программы и трудноуловимым ошибкам.

     -Как обнаружить race condition? 
Для обнаружения гонок данных в Go используется встроенный детектор гонок. Его можно активировать с помощью флага -race при запуске, тестировании или сборке программы:
go run -race main.go
go test -race ./...
go build -race -o myapp
Детектор гонок анализирует выполнение программы и сообщает о найденных гонках данных.


Редко
------------
     -Есть глобальный слайс и я в разных горутинах присваиваю ему аппенд к нему же одного элемента. Будет ли гонка? 
Да, будет гонка данных. Одновременное добавление элементов в глобальный слайс из разных горутин без синхронизации приведет к гонке данных.

     -Где кроме кода может встретиться race condition? 
Гонки данных могут возникать не только в программном коде, но и в аппаратных системах, базах данных, сетевых протоколах и других системах, где несколько процессов или устройств могут одновременно обращаться к общим ресурсам.

     -Какие есть способы устранения race condition?
Мьютексы: Использование мьютексов для синхронизации доступа к общим ресурсам.
Каналы: Использование каналов для передачи данных между горутинами, что обеспечивает безопасный доступ.
Синхронизационные примитивы: Использование других примитивов синхронизации, таких как sync.WaitGroup или sync.Cond.

     -Флаг -race показывает гонку на этапе компиляции или выполнения? 
Флаг -race обнаруживает гонки данных на этапе выполнения программы. Он анализирует выполнение кода и сообщает о найденных гонках данных в реальном времени.




==============================
    Ошибки/Паника
==============================

Редко
-------------
     -Куда нужно помещать recover?
recover следует помещать внутри отложенной функции (defer). Это позволяет перехватить панику и предотвратить крах программы.

     -Какая парадигма в Golang с точки зрения обработки исключений и ошибок?
В Go используется явная обработка ошибок через возвращаемые значения, а не исключения. Для критических ошибок используется panic, а для их перехвата — recover.

     -Какие есть функции для оборачивания и сравнения ошибок?
Для оборачивания ошибок используется fmt.Errorf и errors.Wrap из пакета github.com/pkg/errors. Для сравнения ошибок используется errors.Is и errors.As.
     
     -Для чего используются ошибки, а для чего паника?
Ошибки используются для обработки ожидаемых ситуаций, которые могут возникнуть в ходе выполнения программы. Паника используется для критических ошибок, которые невозможно обработать на месте и требуют немедленного завершения программы.

     -Для чего используется паника?
Паника используется для сигнализации о критических ошибках, таких как выход за пределы массива или попытка разыменования nil-указателя.

     -Есть несколько деферов, в одном из них рековер. Как будет обрабатываться паника? Что если рековер расположен сильно выше и куда бы ты его поместил в случае http вызова? Есть несколько деферов и в одном из них паника, рековер нет, что будет?
Если recover находится в одном из defer, он перехватит панику и программа продолжит выполнение. Если recover расположен выше, он перехватит панику раньше. В случае HTTP вызова recover следует помещать в defer, который оборачивает основной обработчик запроса. Если в defer есть паника, но нет recover, программа завершится с ошибкой.

     -Что используется для обработки паники?
Для обработки паники используется комбинация defer, panic и recover.

     -Чем отличается работа с ошибками в Golang от других языков?
В Go ошибки обрабатываются явно через возвращаемые значения, а не через исключения, как в других языках. Это делает код более предсказуемым и простым для анализа.

     -Что такое паника?
Паника — это встроенная функция в Go, которая останавливает обычный поток выполнения и начинает процесс паники, вызывая все отложенные функции и завершая программу.



==============================
    Указатели
==============================

Средне
-------------
     -Что такое указатель?
Указатель — это переменная, которая хранит адрес другой переменной. В Go указатели позволяют косвенно обращаться к значениям и изменять их, что может быть полезно для оптимизации памяти и производительности.


Редко
-------------
     -Что такое ссылка на значение? 
Ссылка на значение — это способ доступа к значению через его адрес. В Go это реализуется с помощью указателей, которые указывают на адрес переменной в памяти.

     -
Чем отличается ссылка от указателя? В Go нет отдельного понятия “ссылка”, как в некоторых других языках. Указатели выполняют роль ссылок, позволяя косвенно обращаться к значениям через их адреса.

     -Чем чревато передавать структуру по ссылке? 
Передача структуры по ссылке может привести к изменению оригинальной структуры, так как изменения будут происходить по адресу, на который указывает указатель. Это может быть полезно для экономии памяти и повышения производительности, но требует осторожности, чтобы избежать непреднамеренных изменений.

     -Для чего используются указатели? 
Указатели используются для:
Эффективной передачи больших структур в функции.
Реализации изменяемых данных.
Создания сложных структур данных, таких как связные списки и деревья.

     -Для чего в практике используешь указатели? 
В практике указатели используются для оптимизации работы с большими структурами данных, управления памятью и реализации изменяемых данных. Например, при работе с большими массивами или структурами, передача указателя вместо копии может значительно улучшить производительность.

     -Какие есть средства для работы с указателями?
Оператор &: Получение адреса переменной.
Оператор *: Разыменование указателя для доступа к значению по адресу.
Функции new и make: Выделение памяти для новых объектов и срезов.

     -Когда лучше использовать/не использовать указатели?
Использовать указатели: Когда нужно передать большие структуры в функции, изменять значения переменных или работать с динамическими структурами данных.
Не использовать указатели: Когда работа с указателями усложняет код или когда передача по значению более эффективна и безопасна.



==============================
    Дженерики
==============================

Средне
-------------
     -С дженериками работали? 
Да, в Go 1.18 были введены дженерики, что позволило писать функции и типы, которые могут работать с любыми типами данных, определяемыми при вызове.


Редко
------------
     -Чем кодогенерация отличается от дженериков?
Кодогенерация: Это процесс автоматического создания кода на основе шаблонов или аннотаций. Она используется для создания повторяющегося кода, который затем компилируется и выполняется как обычный код. Примером может быть использование инструмента go generate для создания кода на основе аннотаций в исходных файлах.
Дженерики: Позволяют писать обобщенные функции и типы, которые могут работать с различными типами данных без необходимости создания отдельных реализаций для каждого типа. Это достигается за счет использования параметров типов, что делает код более гибким и повторно используемым.

     -В какой версии появились дженерики? 
Дженерики были введены в Go версии 1.18.


==============================
    Конструкции
==============================

Редко
-------------
     -Гарантирует ли порядок выполнения конструкция select-case?
Нет, конструкция select-case не гарантирует порядок выполнения. Если несколько каналов готовы, select выбирает один из них случайным образом.

     -Как выглядит конструкция утверждения типа switch?
Конструкция утверждения типа switch в Go выглядит следующим образом:
Go
var x interface{} = 7
switch i := x.(type) {
case nil:
    fmt.Println("x is nil")
case int:
    fmt.Println("x is", i)
case float64:
    fmt.Println("x is", i)
default:
    fmt.Println("unknown type")
}

     -Нужно ли в switch-case проставлять break?
Нет, в Go не нужно явно указывать break в switch-case, так как выполнение автоматически прекращается после первого совпадения.

     -Какие есть циклы в Golang?
В Go есть только один тип цикла — for. Он может использоваться в различных формах:
Обычный цикл:

for i := 0; i < 10; i++ {
    fmt.Println(i)
}

Цикл с условием:

for i < 10 {
    fmt.Println(i)
    i++
}

Бесконечный цикл:

for {
    fmt.Println("Infinite loop")
}


     -Чем отличается switch от select?
switch используется для выбора одного из нескольких блоков кода на основе значения переменной.
select используется для выбора одного из нескольких каналов для отправки или получения данных. Он блокируется до тех пор, пока один из каналов не станет готов.


==============================
    ООП
==============================

Средне
-------------
     -Как устроено ООП в Golang?
В Go нет классов, но есть структуры и методы, которые позволяют реализовать основные принципы ООП: инкапсуляцию, полиморфизм и композицию. Методы можно прикреплять к структурам, что позволяет создавать объекты с поведением. Интерфейсы в Go позволяют определять наборы методов, которые должны быть реализованы типами, что обеспечивает полиморфизм.

     -Как реализуется наследование в Golang?
В Go нет классического наследования, как в языках с классами (например, Java или C++). Вместо этого используется композиция и встраивание. Композиция позволяет включать одну структуру в другую, что позволяет повторно использовать код. Встраивание позволяет структурам автоматически наследовать методы встроенных структур, что обеспечивает функциональность, аналогичную наследованию.

==============================
    Сборщик мусора
==============================

Редко
-------------
     -Как приходилось работать со сборкой мусора? 
Работа со сборщиком мусора в Go обычно не требует вмешательства разработчика, так как GC автоматически управляет выделением и освобождением памяти. Однако, для оптимизации производительности можно использовать профилировщики и анализаторы памяти, такие как pprof, чтобы выявить узкие места и оптимизировать использование памяти.

     -Как работает GC, его алгоритм и когда запускается? 
GC в Go использует алгоритм “Concurrent Mark-and-Sweep” с трехцветной маркировкой. Алгоритм состоит из двух фаз:
Mark (разметка): GC находит и отмечает все достижимые объекты.
Sweep (очистка): GC проходит по всем объектам и освобождает память недостижимых объектов.
GC запускается автоматически, когда требуется освободить память, чтобы избежать исчерпания ресурсов.

     -Вот выделилась память и она используется, зачем в таком случае нужен GC? 
GC необходим для управления памятью, которая больше не используется. Даже если память выделена и используется, со временем могут появляться объекты, которые больше не нужны. GC освобождает эту память, предотвращая утечки памяти и обеспечивая эффективное использование ресурсов.

     -Для чего используется GC? 
GC используется для автоматического управления памятью, освобождая разработчика от необходимости вручную управлять выделением и освобождением памяти. Это помогает предотвратить утечки памяти и улучшить стабильность и производительность приложений.

     -Какие есть рекомендации как упростить жизнь GC?
Минимизировать количество выделений памяти: Использовать срезы и буферы для повторного использования памяти.
Избегать длинных цепочек ссылок: Это упрощает работу GC при разметке объектов.
Использовать профилировщики: Анализировать использование памяти и оптимизировать код на основе полученных данных.

     -Можно ли как-то отключить GC или ограничить запуски? 
Отключить GC полностью нельзя, так как это приведет к исчерпанию памяти. Однако, можно настроить параметры GC, такие как GOGC, чтобы контролировать частоту его запусков. Например, установка GOGC=off отключает автоматическое увеличение частоты сборки мусора, но это не рекомендуется для большинства приложений.

     -Что такое GC? 
GC (Garbage Collector) — это механизм автоматического управления памятью, который освобождает память, занятую объектами, которые больше не используются.

     -Что такое сборка мусора? 
Сборка мусора — это процесс автоматического освобождения памяти, занятой объектами, которые больше не нужны программе. Это помогает предотвратить утечки памяти и улучшить производительность.




==============================
    Строки
==============================

Средне
-------------
     -Что такое string?
В Go строка (string) — это последовательность байтов, представляющих текстовые данные. Строки в Go неизменяемы, что означает, что после создания строки её содержимое нельзя изменить.


Редко
-------------
     -Приходит строка в utf8, там могут быть русские символы. Как узнать есть ли там русские буквы и как узнать длину в символах?
Для проверки наличия русских букв можно использовать функцию strings.ContainsFunc с проверкой на диапазон Unicode для русских символов:

import (
    "strings"
    "unicode"
)

func containsRussian(s string) bool {
    return strings.ContainsFunc(s, func(r rune) bool {
        return unicode.Is(unicode.Cyrillic, r)
    })
}


Для определения длины строки в символах (рунах) можно использовать функцию utf8.RuneCountInString:

import (
    "fmt"
    "unicode/utf8"
)

func main() {
    s := "Привет, мир!"
    fmt.Println(utf8.RuneCountInString(s)) // Вывод: 12
}

     -Какие особенности есть у string?
Строки в Go неизменяемы.
Строки могут содержать любые байты, включая нулевые байты.
Строки поддерживают UTF-8, что позволяет хранить и обрабатывать текст на различных языках.

     -Как работать с utf8 строкой?
Для работы с UTF-8 строками можно использовать пакет unicode/utf8, который предоставляет функции для декодирования и работы с рунами:

import (
    "fmt"
    "unicode/utf8"
)

func main() {
    s := "Привет, мир!"
    for i, r := range s {
        fmt.Printf("%d: %c\n", i, r)
    }
}



==============================
    Структуры
==============================

Редко
-------------
     -Имеет ли значение порядок полей в структуре?
Да, порядок полей в структуре имеет значение для выравнивания и размера структуры. Поля выравниваются в памяти в зависимости от их типа, и неправильный порядок может привести к увеличению размера структуры из-за добавления дополнительных байтов для выравнивания.

     -От чего зависит размер выравнивания в структуре?
Размер выравнивания в структуре зависит от типов данных полей. Разные типы данных имеют разные требования к выравниванию. Например, int64 требует выравнивания по 8 байтам, а int32 — по 4 байтам. Компилятор автоматически добавляет дополнительные байты (паддинг) для соблюдения этих требований.

     -Что такое структура?
Структура в Go — это пользовательский тип данных, который позволяет объединять переменные разных типов в одну логическую единицу. Структуры используются для группировки связанных данных и упрощения их обработки. Пример объявления структуры:

type Person struct {
    Name string
    Age  int
}

==============================
    Пакеты
==============================

Редко
-------------
     -Что такое пакет?
Пакет в Go — это коллекция связанных Go-файлов, которые организованы в одну директорию и имеют одинаковое имя пакета, указанное в начале каждого файла. Пакеты позволяют структурировать код, делая его более модульным и повторно используемым. Пакеты могут быть двух типов:
Исполняемые (executable): Пакеты с именем main, которые содержат функцию main и могут быть скомпилированы в исполняемые файлы.
Библиотеки (reusable): Пакеты с любым другим именем, которые можно импортировать и использовать в других пакетах.

     -Расскажи про папку internal
Папка internal в Go используется для ограничения видимости пакетов. Пакеты, находящиеся внутри папки internal, могут быть импортированы только из родительского пакета и его поддиректорий. Это позволяет создавать пакеты, которые не могут быть использованы за пределами определенного модуля или проекта, обеспечивая лучшую инкапсуляцию и предотвращая случайное использование внутренних деталей реализации.
