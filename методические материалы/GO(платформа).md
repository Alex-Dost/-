# Типы данных  
---
---

### 1. Простейшие типы данных

#### 1.1. Целочисленные типы

- int: стандартный целочисленный тип, размер зависит от платформы (32 или 64 бита).
  
- int8, int16, int32, int64: целые числа с фиксированным размером в битах.
  
- uint, uint8, uint16, uint32, uint64: беззнаковые целые числа.

_Пример_:

```go
var a int = 10
var b uint8 = 200
```

#### 1.2. Числа с плавающей запятой

- float32, float64: числа с плавающей точкой, где float64 имеет большую точность и диапазон.

_Пример_:
  
```go
var pi float64 = 3.14159
```

#### 1.3. Комплексные числа

- complex64, complex128: для работы с комплексными числами.

_Пример_:

```go
var c complex128 = 1 + 2i
```

### 2. Символьные типы

#### 2.1. Символы

- rune: представляет собой Unicode символ (эквивалент int32).

 _Пример_:
 
```go
var letter rune = 'A'
```

#### 2.2. Строки

- string: последовательность символов. Строки в Go неизменяемы.

_Пример_:

```go
var greeting string = "Hello, World!"
```

### 3. Составные типы данных

#### 3.1. Массивы

- Массивы фиксированного размера, содержащие элементы одного типа.

_Пример_:

```go
var numbers [5]int = [5]int{1, 2, 3, 4, 5}
```

#### 3.2. Срезы (Slices)

- Срезы — это динамические массивы, предоставляющие более гибкое управление длиной.

_Пример_:

```go
var colors []string = []string{"red", "green", "blue"}
```

#### 3.3. Структуры

- Структуры позволяют объединять несколько значений различных типов в одно новое значение.

_Пример_:

```go
type Person struct {
    Name string
    Age  int
}

var p Person = Person{Name: "Alice", Age: 30}
```

#### 3.4. Карты (Maps)

- Карты — это ассоциативные массивы (или хэш-таблицы), которые связывают ключи и значения.

_Пример_:

```go
var ageMap map[string]int = map[string]int{"Alice": 30, "Bob": 25}
```

### 4. Функциональные типы

- В Go функции являются первоклассными объектами, что позволяет объявлять функции как типы.

_Пример_:

```go
type MathFunc func(int, int) int

func add(a, b int) int {
    return a + b
}

var myFunc MathFunc = add
```

### Нюансы использования типов данных в Go

- **Неявная конвертация типов:** Go не поддерживает неявную конвертацию типов, что требует явного преобразования.

- **Инициализация типов:** Переменные любой структуры и массива всегда инициализируются нулевыми значениями их типов.

- **Аллокация памяти:** Срезы и карты используют динамическое выделение памяти, поэтому следует быть внимательным с их размером.

- **Неизменяемость строк:** Строки в Go неизменяемы, что делает их безопасными при передаче в функцию, но может вызвать дополнительные накладные расходы.

# Структуры - мапы/слайсы  
---
---

### Что это?

- **Мапа** представляет собой неупорядоченную коллекцию пар "ключ-значение". Она позволяет быстро получать доступ к значениям по ключам.
    - Ключи могут быть любыми типами, которые сравнимы (например, строки, числа).
    - Значения могут быть любыми типами.
    - Быстрая выборка значений по ключу.

- **Слайс** — это абстракция, представляющая собой динамический массив, который может изменять свой размер.
    - Слайсы являются ссылочными типами, т.е. при передаче в функции передается ссылка, а не копируются значения.
    - Они состоят из трех компонентов: указателя на первый элемент, длины и емкости (capacity).

### Пример

_Пример создания и использования мапы:_

```go
package main

import (
 "fmt"
)

func main() {
 // Создание мапы
 age := make(map[string]int)

 // Добавление значений
 age["Alice"] = 25
 age["Bob"] = 30

 // Получение значения по ключу
 fmt.Println("Alice's age:", age["Alice"])

 // Удаление значения
 delete(age, "Bob")

 // Проверка существования ключа
 if val, exists := age["Bob"]; exists {
  fmt.Println("Bob's age:", val)
 } else {
  fmt.Println("Bob not found")
 }
}
```

_Пример создания и использования слайса_

```go
package main

import (
 "fmt"
)

func main() {
 // Создание слайса
 numbers := []int{1, 2, 3}

 // Добавление элементов
 numbers = append(numbers, 4, 5)

 // Итерация по слайсу
 for i, num := range numbers {
  fmt.Printf("Index %d: %d\n", i, num)
 }

 // Извлечение подмассива (среза)
 subSlice := numbers[1:4]
 fmt.Println("Subslice:", subSlice)
}
```

### Нюансы  

**Нюансы при работе с мапами:**    

- При обращении к отсутствующему ключу возвращается нулевое значение типа значений.
- Мапы являются ссылочными типами, т.е. передача мапы в функции происходит по ссылке.  

**Нюансы при работе с слайсами:**    

- При добавлении в полный слайс создается новый слайс с увеличенной емкостью.
- Слайсы могут ссылаться на одну и ту же область памяти, что требует осторожности при изменениях.

# Как устроено управление памятью  
---
---

- Управление памятью в языке Go основано на автоматическом сборе мусора (Garbage Collection), что позволяет разработчикам сосредоточиться на написании кода, а не на управлении памятью вручную.

### Основы управления памятью

- **Аллокация памяти:** Когда вы создаете переменные, структуры или массивы, Go автоматически выделяет необходимое количество памяти. Это делается с помощью malloc под капотом.
  
- **Освобождение памяти:** Go использует сборщик мусора для автоматического освобождения памяти, которая больше не используется. Это предотвращает утечки памяти и оптимизирует использование ресурсов.  

_Пример аллокации и использования памяти:_

```go
package main

import (
 "fmt"
)

type Person struct {
 Name string
 Age  int
}

func main() {
 // Создание переменной и структуры
 p := Person{Name: "Alice", Age: 30}

 // Аллокация памяти под срез
 numbers := make([]int, 0, 5)

 // Добавление элементов
 numbers = append(numbers, 1, 2, 3)

 fmt.Println(p)
 fmt.Println(numbers)
}
```

### Сбор мусора

- Сборка мусора в Go запускается автоматически. Он отслеживает все используемые объекты в памяти и освобождает те, которые больше не имеют ссылок.

### Нюансы работы сборщика мусора:

- **Тайминг:** Сборка мусора может вызываться в любой момент, поэтому важно понимать, как ваши функции могут быть производительными при его работе.
  
- **Сборщик мусора в Go:** Он использует алгоритм консервативной сборки мусора, что снижает нагрузки на систему и увеличивает производительность.  

_Пример вывода в консоли о процессе сборки мусора:_

```go
package main

import (
 "fmt"
 "runtime"
)

func main() {
 var memStats runtime.MemStats
 runtime.ReadMemStats(&memStats)

 fmt.Printf("Alloc = %v MiB", memStats.Alloc / 1024 / 1024)
 fmt.Printf("\tTotalAlloc = %v MiB", memStats.TotalAlloc / 1024 / 1024)
 fmt.Printf("\tSys = %v MiB", memStats.Sys / 1024 / 1024)
}
```

### Оптимизация использования памяти

- **Избегание утечек памяти:** Убедитесь, что нет циклических ссылок, которые могут мешать сборщику мусора.
  
- **Измерение памяти:** Используйте `runtime` пакет для мониторинга использования памяти и понимания поведения вашего приложения.

- **Значимые и ссылочные типы:** Помните, что некоторые типы (например, слайсы и карты) являются ссылочными, и изменения в одной функции могут повлиять на данные в другой.

- **Структуры:** Используйте `struct` и "по значению" вместо указателей, если это возможно, чтобы избежать ненужных аллокаций.

# Что такое планировщик и очереди  
---
---

## Планировщик

### Как работает планировщик

- Планировщик в Go отвечает за распределение выполнения goroutines (легковесных потоков) по доступным операционным системам. Он управляет состоянием goroutines и обеспечивает оптимальное использование ресурсов.  

**G, M, и P: В Go концепция планировщика основана на трех основных компонентах:**  
    - **G (goroutine):** Легковесный поток выполнения.
    - **M (machine):** Операционная система или поток, который исполняет goroutines.
    - **P (processor):** Контекст выполнения, который управляет goroutines. Каждый P может обрабатывать только одну goroutine одновременно.
    - Работа с очередями: Когда goroutine блокируется (например, ожидает I/O), планировщик отправляет её в очередь на ожидание, чтобы освободить M для выполнения других goroutines. Это позволяет эффективно использовать ресурсы и не блокировать потоки.  

_Пример использования goroutines и планировщика:_

```go
package main

import (
 "fmt"
 "sync"
 "time"
)

func worker(id int, wg *sync.WaitGroup) {
 defer wg.Done()
 fmt.Printf("Worker %d is starting\n", id)
 time.Sleep(time.Second)
 fmt.Printf("Worker %d is done\n", id)
}

func main() {
 var wg sync.WaitGroup

 for i := 1; i <= 5; i++ {
  wg.Add(1)
  go worker(i, &wg)
 }

 wg.Wait()
 fmt.Println("All workers are done.")
}
```

## Очереди

- Очереди в Go обычно используются в контексте каналов (channels) для организации коммуникации между goroutines. Они позволяют эффективно передавать данные и синхронизировать выполнение.

### Каналы как очереди

- **Неограниченные каналы:** Если канал не ограничен по размеру, он будет хранить все отправленные элементы до тех пор, пока не будет получен.

- **Ограниченные каналы:** Вы можете задать размер канала, и если он заполнен, отправляющие операции блокируются до тех пор, пока не будет прочитано одно или несколько значений.  

_Пример использования каналов (очередей):_

```go
package main

import (
 "fmt"
 "time"
)

func producer(ch chan<- int) {
 for i := 0; i < 5; i++ {
  fmt.Println("Producing:", i)
  ch <- i
  time.Sleep(time.Millisecond * 500)
 }
 close(ch)
}

func consumer(ch <-chan int) {
 for item := range ch {
  fmt.Println("Consuming:", item)
  time.Sleep(time.Second)
 }
}

func main() {
 ch := make(chan int, 3) // Ограниченный канал

 go producer(ch)
 consumer(ch)
}
```

### Нюансы работы с планировщиком и очередями

- **Контекст выполнения:** При использовании goroutines и каналов важно учитывать контекст выполнения. Параллельные операции могут привести к гонкам данных, если они работают с общими ресурсами без должной синхронизации.

- **Синхронизация:** Используйте механизмы синхронизации, такие как sync.WaitGroup, для управления выполнением goroutines и ожидания их завершения.

- **Производительность:** Надо отметить, что слишком много goroutines или неправильная конфигурация очередей могут привести к ухудшению производительности. Важно находить баланс.

# Параллелизм и асинхронность  
---
---

### Что это?

- **Параллелизм** — это выполнение нескольких вычислений одновременно. Go предоставляет возможность запускать несколько «горутин» (легковесных потоков), которые могут выполняться параллельно. 

- **Асинхронность** — это стиль программирования, при котором выполнение операций происходит не в основном потоке, а в фоновом режиме. Это позволяет основному потоку продолжать выполнение других задач, не дожидаясь завершения фоновой задачи.  

В Go параллелизм осуществляется через «горутины», а асинхронные операции могут быть реализованы с использованием каналов.

### Примеры

1. Параллелизм с горутинами:  

```go
package main

import (
    "fmt"
    "time"
)

func task(id int) {
    fmt.Printf("Task %d is starting\n", id)
    time.Sleep(2 * time.Second) // Имитация выполнения
    fmt.Printf("Task %d is completed\n", id)
}

func main() {
    for i := 1; i <= 5; i++ {
        go task(i) // Запускаем горутину
    }
    time.Sleep(5 * time.Second) // Ждем завершения всех горутин
    fmt.Println("All tasks have finished.")
}
```

2. Асинхронность с использованием каналов:  

```go
package main

import (
    "fmt"
    "time"
)

func asyncTask(id int, ch chan<- string) {
    time.Sleep(2 * time.Second) // Имитация выполнения
    ch <- fmt.Sprintf("Task %d completed", id)
}

func main() {
    ch := make(chan string)

    for i := 1; i <= 5; i++ {
        go asyncTask(i, ch) // Запускаем асинхронные задачи
    }

    for i := 1; i <= 5; i++ {
        fmt.Println(<-ch) // Получаем результаты
    }
    fmt.Println("All tasks have finished.")
}
```

### Нюансы

1. **Горутины:** 
    - Горутины легче и дешевле в создании по сравнению с обычными потоками. Их контекст переключается быстрее, что позволяет эффективно управлять большим количеством параллельных задач.
    - Они зависимы от планировщика Go, что позволяет автоматически распределять их по доступным потокам.

2. **Каналы:**
    - Каналы являются основным способом обмена данными между горутинами. Они обеспечивают безопасный доступ к данным и синхронизацию работы.
    - Важно правильно использовать каналы для предотвращения блокировок и дедлоков.

3. **Планирование:**
    - Go имеет встроенный планировщик, который управляет выполнением горутин. Это делает параллелизм более эффективным, но взамен требует учета возможных зависимостей между задачами.

4. **Проблемы синхронизации:**
    - Убедитесь, что при использовании горутин вы контролируете доступ к общим данным. Не забудьте использовать мьютексы или каналы для предотвращения гонок данных.

5. **Отладка и мониторинг:**
    - Отладка и мониторинг параллельных приложений могут быть сложными. Используйте профилирование и логи для выявления проблем.

# Примитивы синхронизации  
---
---

### Что это?

- **Примитивы синхронизации в Go** — это инструменты, которые позволяют управлять доступом к общим ресурсам и избегать гонок данных при работе с горутинами. Они обеспечивают безопасное взаимодействие между параллельными задачами.

### Описание

Существуют несколько основных примитивов синхронизации в Go:  

1. **Мьютексы:** используются для взаимного исключения, то есть предотвращают одновременный доступ к общему ресурсу.

2. **Рд-Зап (RWMutex):** расширение мьютексов, позволяющее нескольким читателям одновременно получать доступ к ресурсу, но блокирующее его для записи.

3. **Сигнализация с помощью WaitGroup:** позволяет ожидать завершения нескольких горутин, что упрощает управление их жизненным циклом.

4. **Каналы:** хотя их основное предназначение — обмен данными, каналы также могут служить примитивом синхронизации, так как блокируют выполнение горутины до тех пор, пока не будет отправлено или принято сообщение.

5. **Сигналы (Cond):** используются для оповещения одной или нескольких горутин о том, что произошли определенные изменения, которые могут повлиять на их выполнение.

### Примеры

1. **Мьютексы:**

```go
package main

import (
    "fmt"
    "sync"
)

var (
    counter int
    mutex   sync.Mutex
)

func increment(wg *sync.WaitGroup) {
    defer wg.Done()
    mutex.Lock()
    counter++
    mutex.Unlock()
}

func main() {
    var wg sync.WaitGroup

    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go increment(&wg)
    }

    wg.Wait()
    fmt.Println("Final count:", counter)
}
```

2. **RWMutex:**

```go
package main

import (
    "fmt"
    "sync"
)

var (
    data  int
    rwmux sync.RWMutex
)

func read(wg *sync.WaitGroup) {
    defer wg.Done()
    rwmux.RLock()
    fmt.Println("Read data:", data)
    rwmux.RUnlock()
}

func write(wg *sync.WaitGroup) {
    defer wg.Done()
    rwmux.Lock()
    data++
    fmt.Println("Data incremented")
    rwmux.Unlock()
}

func main() {
    var wg sync.WaitGroup

    for i := 0; i < 5; i++ {
        wg.Add(1)
        go read(&wg)
        wg.Add(1)
        go write(&wg)
    }

    wg.Wait()
}
```

3. **WaitGroup:**

```go
package main

import (
    "fmt"
    "sync"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    fmt.Printf("Worker %d is processing\n", id)
}

func main() {
    var wg sync.WaitGroup

    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go worker(i, &wg)
    }

    wg.Wait()
    fmt.Println("All workers have finished.")
}
```

4. **Каналы:**

```go
package main

import (
    "fmt"
)

func worker(id int, ch chan<- int) {
    fmt.Printf("Worker %d is processing\n", id)
    ch <- id // Отправляем идентификатор работника по каналу
}

func main() {
    ch := make(chan int)

    for i := 1; i <= 5; i++ {
        go worker(i, ch)
    }

    for i := 1; i <= 5; i++ {
        fmt.Println("Worker finished with id:", <-ch) // Получаем результат через канал
    }
}
```

5. **Сигналы (Cond):**

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

var (
    cond   = sync.NewCond(&sync.Mutex{})
    ready  = false
)

func worker() {
    cond.L.Lock()
    for !ready {
        cond.Wait() // Ожидание сигнала
    }
    fmt.Println("Worker is processing")
    cond.L.Unlock()
}

func main() {
    go worker()

    time.Sleep(2 * time.Second)
    cond.L.Lock()
    ready = true
    cond.Signal() // Оповещение работника
    cond.L.Unlock()

    time.Sleep(1 * time.Second)
}
```

### Нюансы

1. **Сложность управления:** Правильное применение примитивов синхронизации может быть сложным. Ошибки могут привести к дедлокам или гонкам данных. Важно тщательно продумывать архитектуру и использовать инструменты, такие как go vet или race detector, для выявления потенциальных проблем.

2. **Производительность:** Примитивы синхронизации могут влиять на производительность приложения. Мьютексы и блокировки могут вызывать задержки, особенно если они используются слишком часто. Стремитесь минимизировать время блокировок и использовать более легковесные структуры, такие как каналы, когда это возможно.

3. **Избегание гонок данных:** Всегда проверяйте наличие гонок данных в вашем коде. Использование мьютексов, каналов и других примитивов синхронизации помогает избежать конфликтов при параллельном доступе к общим переменным.

4. **Правильное использование сигналов и ожиданий:** Используйте WaitGroup и Cond для управления завершением горутин и синхронизацией при изменениях состояния. Это позволяет избежать возможных проблем, связанных с преждевременным завершением программы.

# Классы и интерфейсы  
---
---


В языке Go нет классов в традиционном понимании, как в объектно-ориентированных языках, таких как Java или C++. Вместо классов используются структуры для создания объектов, а интерфейсы обеспечивают полиморфизм и возможность работы с различными типами.

### Описание

1. **Структуры:** это составные типы, которые позволяют объединять различные поля (атрибуты) под одним именем. Структуры в Go могут содержать методы, что позволяет им вести себя аналогично объектам.

2. **Интерфейсы:** это тип, который определяет набор методов. Интерфейс не содержит реализации; любой тип, который реализует методы интерфейса, считается его реализацией. Это позволяет создавать гибкие и расширяемые программы.

### Примеры

1. **Структуры:**

```go
package main

import "fmt"

// Определение структуры
type Person struct {
    Name string
    Age  int
}

// Метод для структуры Person
func (p Person) Greet() {
    fmt.Printf("Привет, меня зовут %s, мне %d лет.\n", p.Name, p.Age)
}

func main() {
    // Создание экземпляра структуры
    person := Person{Name: "Иван", Age: 30}
    person.Greet() // Вызов метода
}
```

2. **Интерфейсы:**

```go
package main

import "fmt"

// Определение интерфейса
type Greeter interface {
    Greet()
}

// Реализация интерфейса для структуры Person
func (p Person) Greet() {
    fmt.Printf("Привет, я - %s\n", p.Name)
}

// Структура другой сущности
type Dog struct {
    Name string
}

// Реализация интерфейса для структуры Dog
func (d Dog) Greet() {
    fmt.Printf("Гав! Я - %s\n", d.Name)
}

// Функция, использующая интерфейс
func SayHello(g Greeter) {
    g.Greet()
}

func main() {
    person := Person{Name: "Иван"}
    dog := Dog{Name: "Бобик"}

    SayHello(person) // Вызов с экземпляром Person
    SayHello(dog)    // Вызов с экземпляром Dog
}
```

3. **Проверка типов интерфейсов:**

```go
package main

import "fmt"

type Animal interface {
    Speak() string
}

type Cat struct {}

func (c Cat) Speak() string {
    return "Мяу"
}

type Duck struct {}

func (d Duck) Speak() string {
    return "Ква-ква"
}

func PrintSound(a Animal) {
    fmt.Println(a.Speak())
}

func main() {
    var a Animal

    a = Cat{}
    PrintSound(a) // вывод: Мяу

    a = Duck{}
    PrintSound(a) // вывод: Ква-ква
}
```

### Нюансы

1. Отсутствие явного указания на реализацию интерфейса: В Go тип становится реализацией интерфейса автоматически, если он реализует все методы интерфейса. Это позволяет легко расширять код, добавляя новые типы без необходимости явного указания на интерфейсы.

2. Пустой интерфейс: Пустой интерфейс `interface{}` может содержать значение любого типа. Это может быть полезно, но использование пустого интерфейса часто приводит к особенностям, связанным с безопасностью типов и необходимостью явного приведения типов.

3. Методы структур: Методы могут быть определены не только для структур, но и для указателей на структуры. Это может повлиять на производительность и поведение программы, особенно при изменении состояния структуры.

4. Интерфейсы для хранения различных типов: Интерфейсы позволяют создавать функции, которые могут принимать аргументы различных типов, упрощая разработку гибких и расширяемых API.

5. Поддержка композиции: Go ориентирован на композицию, а не на наследование. Это означает, что стоит сосредоточиться на создании небольших и повторно используемых интерфейсов и структур, которые могут быть объединены для достижения нужного результата.

# Стандартные инструменты разработки 
---
---

### Описание основных инструментов

1. **Go Compiler (goc)**  

Компилятор Go отвечает за преобразование исходного кода в исполняемый файл. Он также проверяет синтаксис и может оптимизировать код.
   
```bash
go build <путь к пакету>
```  

2. **Go Modules (gomod)**  

Go Modules — это система управления зависимостями, позволяющая разработчикам указывать и контролировать версии библиотек, которые используются в проекте.

```bash
go mod init <имя модуля>
```   

3. **Go Get (go get)**  

   Этот инструмент используется для загрузки и установки внешних пакетов. Он обновляет файл go.mod с новыми зависимостями.

```bash
go get <имя пакета>
```

4. **Go Test (go test)**  

   Go Test позволяет запускать юнит-тесты для пакетов, проверяя корректность работы функций и методов.

```bash
   go test <путь к пакету>
```   

5. **Go Vet (go vet)**  

   Этот инструмент выполняет статический анализ кода, обнаруживая потенциальные ошибки и проблемы, которые могут возникнуть во время выполнения.

```bash
go vet <путь к пакету>
```   

6. **Go Fmt (go fmt)**  

   Go Fmt форматирует исходный код в соответствии с установленными стандартами, что помогает поддерживать единый стиль кода в команде.
  
```bash
go fmt <путь к пакету>
```   

7. **Go Doc (go doc)**  

   Этот инструмент предоставляет документацию для пакетов и функций. Он помогает быстро находить нужную информацию о типах и методах.

```bash
go doc <имя пакета>.<функция>
```   

8. **Go Run (go run)**  

   С помощью go run можно скомпилировать и сразу запустить Go-файлы, что удобно для быстрого тестирования кода.

```bash
go run <имя файла.go>
```   

### Примеры использования инструментов

1. **Сборка приложения:**  
   
   Сборка проекта может быть выполнена с помощью:

```bash
go build
```   
 Это создаст исполняемый файл в текущей директории.

2. **Запуск тестов:**  

   Для запуска всех тестов в проекте можно использовать:
   
```bash
go test ./...
```   
   Эта команда найдет и выполнит все тесты во всех подкаталогах.

3. **Добавление зависимости:**  

   Чтобы добавить пакет (например, для тестирования):

```bash
go get github.com/stretchr/testify
```   
   Это действие обновит файл go.mod.

4. **Форматирование кода:**  

   Для автоматического форматирования всего проекта:

```bash
go fmt ./...
```   
   Это обеспечит соответствие кода стандартам.

5. **Анализ кода:**

   Для статической проверки:

```bash
go vet ./...
```   
   Это поможет выявить потенциальные ошибки.

### Нюансы работы с инструментами

1. Управление модулями: Рекомендуется активно использовать модули, начиная с Go 1.11. Это упрощает управление зависимостями и позволяет избежать конфликтов версий.

2. Структура пакетов: Каждый пакет обычно располагается в отдельной директории, что улучшает организацию кода.

3. Анализ и тестирование: Инструменты, такие как go vet и go test, должны быть частью рабочего процесса для предотвращения ошибок и проверки качества кода.

4. Документирование: Для автоматической генерации документации важно использовать комментарии к функциям и пакетам.

5. Интеграция в CI/CD: Инструменты Go могут быть использованы в процессе непрерывной интеграции и развертывания, что позволяет автоматизировать тестирование и проверку качества.





