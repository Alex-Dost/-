# Типы данных  
---
---

### 1. Простейшие типы данных

#### 1.1. Целочисленные типы

- int: стандартный целочисленный тип, размер зависит от платформы (32 или 64 бита).
  
- int8, int16, int32, int64: целые числа с фиксированным размером в битах.
  
- uint, uint8, uint16, uint32, uint64: беззнаковые целые числа.

_Пример_:

```go
var a int = 10
var b uint8 = 200
```

#### 1.2. Числа с плавающей запятой

- float32, float64: числа с плавающей точкой, где float64 имеет большую точность и диапазон.

_Пример_:
  
```go
var pi float64 = 3.14159
```

#### 1.3. Комплексные числа

- complex64, complex128: для работы с комплексными числами.

_Пример_:

```go
var c complex128 = 1 + 2i
```

### 2. Символьные типы

#### 2.1. Символы

- rune: представляет собой Unicode символ (эквивалент int32).

 _Пример_:
 
```go
var letter rune = 'A'
```

#### 2.2. Строки

- string: последовательность символов. Строки в Go неизменяемы.

_Пример_:

```go
var greeting string = "Hello, World!"
```

### 3. Составные типы данных

#### 3.1. Массивы

- Массивы фиксированного размера, содержащие элементы одного типа.

_Пример_:

```go
var numbers [5]int = [5]int{1, 2, 3, 4, 5}
```

#### 3.2. Срезы (Slices)

- Срезы — это динамические массивы, предоставляющие более гибкое управление длиной.

_Пример_:

```go
var colors []string = []string{"red", "green", "blue"}
```

#### 3.3. Структуры

- Структуры позволяют объединять несколько значений различных типов в одно новое значение.

_Пример_:

```go
type Person struct {
    Name string
    Age  int
}

var p Person = Person{Name: "Alice", Age: 30}
```

#### 3.4. Карты (Maps)

- Карты — это ассоциативные массивы (или хэш-таблицы), которые связывают ключи и значения.

_Пример_:

```go
var ageMap map[string]int = map[string]int{"Alice": 30, "Bob": 25}
```

### 4. Функциональные типы

- В Go функции являются первоклассными объектами, что позволяет объявлять функции как типы.

_Пример_:

```go
type MathFunc func(int, int) int

func add(a, b int) int {
    return a + b
}

var myFunc MathFunc = add
```

### Нюансы использования типов данных в Go

- **Неявная конвертация типов:** Go не поддерживает неявную конвертацию типов, что требует явного преобразования.

- **Инициализация типов:** Переменные любой структуры и массива всегда инициализируются нулевыми значениями их типов.

- **Аллокация памяти:** Срезы и карты используют динамическое выделение памяти, поэтому следует быть внимательным с их размером.

- **Неизменяемость строк:** Строки в Go неизменяемы, что делает их безопасными при передаче в функцию, но может вызвать дополнительные накладные расходы.

# Структуры - мапы/слайсы  
---
---

### Что это?

- **Мапа** представляет собой неупорядоченную коллекцию пар "ключ-значение". Она позволяет быстро получать доступ к значениям по ключам.
    - Ключи могут быть любыми типами, которые сравнимы (например, строки, числа).
    - Значения могут быть любыми типами.
    - Быстрая выборка значений по ключу.

- **Слайс** — это абстракция, представляющая собой динамический массив, который может изменять свой размер.
    - Слайсы являются ссылочными типами, т.е. при передаче в функции передается ссылка, а не копируются значения.
    - Они состоят из трех компонентов: указателя на первый элемент, длины и емкости (capacity).

### Пример

_Пример создания и использования мапы:_

```go
package main

import (
 "fmt"
)

func main() {
 // Создание мапы
 age := make(map[string]int)

 // Добавление значений
 age["Alice"] = 25
 age["Bob"] = 30

 // Получение значения по ключу
 fmt.Println("Alice's age:", age["Alice"])

 // Удаление значения
 delete(age, "Bob")

 // Проверка существования ключа
 if val, exists := age["Bob"]; exists {
  fmt.Println("Bob's age:", val)
 } else {
  fmt.Println("Bob not found")
 }
}
```

_Пример создания и использования слайса_

```go
package main

import (
 "fmt"
)

func main() {
 // Создание слайса
 numbers := []int{1, 2, 3}

 // Добавление элементов
 numbers = append(numbers, 4, 5)

 // Итерация по слайсу
 for i, num := range numbers {
  fmt.Printf("Index %d: %d\n", i, num)
 }

 // Извлечение подмассива (среза)
 subSlice := numbers[1:4]
 fmt.Println("Subslice:", subSlice)
}
```

### Нюансы  

**Нюансы при работе с мапами:**    

- При обращении к отсутствующему ключу возвращается нулевое значение типа значений.
- Мапы являются ссылочными типами, т.е. передача мапы в функции происходит по ссылке.  

**Нюансы при работе с слайсами:**    

- При добавлении в полный слайс создается новый слайс с увеличенной емкостью.
- Слайсы могут ссылаться на одну и ту же область памяти, что требует осторожности при изменениях.

# Как устроено управление памятью  
---
---

- Управление памятью в языке Go основано на автоматическом сборе мусора (Garbage Collection), что позволяет разработчикам сосредоточиться на написании кода, а не на управлении памятью вручную.

### Основы управления памятью

- **Аллокация памяти:** Когда вы создаете переменные, структуры или массивы, Go автоматически выделяет необходимое количество памяти. Это делается с помощью malloc под капотом.
  
- **Освобождение памяти:** Go использует сборщик мусора для автоматического освобождения памяти, которая больше не используется. Это предотвращает утечки памяти и оптимизирует использование ресурсов.  

_Пример аллокации и использования памяти:_

```go
package main

import (
 "fmt"
)

type Person struct {
 Name string
 Age  int
}

func main() {
 // Создание переменной и структуры
 p := Person{Name: "Alice", Age: 30}

 // Аллокация памяти под срез
 numbers := make([]int, 0, 5)

 // Добавление элементов
 numbers = append(numbers, 1, 2, 3)

 fmt.Println(p)
 fmt.Println(numbers)
}
```

### Сбор мусора

- Сборка мусора в Go запускается автоматически. Он отслеживает все используемые объекты в памяти и освобождает те, которые больше не имеют ссылок.

### Нюансы работы сборщика мусора:

- **Тайминг:** Сборка мусора может вызываться в любой момент, поэтому важно понимать, как ваши функции могут быть производительными при его работе.
  
- **Сборщик мусора в Go:** Он использует алгоритм консервативной сборки мусора, что снижает нагрузки на систему и увеличивает производительность.  

_Пример вывода в консоли о процессе сборки мусора:_

```go
package main

import (
 "fmt"
 "runtime"
)

func main() {
 var memStats runtime.MemStats
 runtime.ReadMemStats(&memStats)

 fmt.Printf("Alloc = %v MiB", memStats.Alloc / 1024 / 1024)
 fmt.Printf("\tTotalAlloc = %v MiB", memStats.TotalAlloc / 1024 / 1024)
 fmt.Printf("\tSys = %v MiB", memStats.Sys / 1024 / 1024)
}
```

### Оптимизация использования памяти

- **Избегание утечек памяти:** Убедитесь, что нет циклических ссылок, которые могут мешать сборщику мусора.
  
- **Измерение памяти:** Используйте `runtime` пакет для мониторинга использования памяти и понимания поведения вашего приложения.

- **Значимые и ссылочные типы:** Помните, что некоторые типы (например, слайсы и карты) являются ссылочными, и изменения в одной функции могут повлиять на данные в другой.

- **Структуры:** Используйте `struct` и "по значению" вместо указателей, если это возможно, чтобы избежать ненужных аллокаций.

# Что такое планировщик и очереди  
---
---

## Планировщик

### Как работает планировщик

- Планировщик в Go отвечает за распределение выполнения goroutines (легковесных потоков) по доступным операционным системам. Он управляет состоянием goroutines и обеспечивает оптимальное использование ресурсов.  

**G, M, и P: В Go концепция планировщика основана на трех основных компонентах:**  
    - **G (goroutine):** Легковесный поток выполнения.
    - **M (machine):** Операционная система или поток, который исполняет goroutines.
    - **P (processor):** Контекст выполнения, который управляет goroutines. Каждый P может обрабатывать только одну goroutine одновременно.
    - Работа с очередями: Когда goroutine блокируется (например, ожидает I/O), планировщик отправляет её в очередь на ожидание, чтобы освободить M для выполнения других goroutines. Это позволяет эффективно использовать ресурсы и не блокировать потоки.  

_Пример использования goroutines и планировщика:_

```go
package main

import (
 "fmt"
 "sync"
 "time"
)

func worker(id int, wg *sync.WaitGroup) {
 defer wg.Done()
 fmt.Printf("Worker %d is starting\n", id)
 time.Sleep(time.Second)
 fmt.Printf("Worker %d is done\n", id)
}

func main() {
 var wg sync.WaitGroup

 for i := 1; i <= 5; i++ {
  wg.Add(1)
  go worker(i, &wg)
 }

 wg.Wait()
 fmt.Println("All workers are done.")
}
```

## Очереди

- Очереди в Go обычно используются в контексте каналов (channels) для организации коммуникации между goroutines. Они позволяют эффективно передавать данные и синхронизировать выполнение.

### Каналы как очереди

- **Неограниченные каналы:** Если канал не ограничен по размеру, он будет хранить все отправленные элементы до тех пор, пока не будет получен.

- **Ограниченные каналы:** Вы можете задать размер канала, и если он заполнен, отправляющие операции блокируются до тех пор, пока не будет прочитано одно или несколько значений.  

_Пример использования каналов (очередей):_

```go
package main

import (
 "fmt"
 "time"
)

func producer(ch chan<- int) {
 for i := 0; i < 5; i++ {
  fmt.Println("Producing:", i)
  ch <- i
  time.Sleep(time.Millisecond * 500)
 }
 close(ch)
}

func consumer(ch <-chan int) {
 for item := range ch {
  fmt.Println("Consuming:", item)
  time.Sleep(time.Second)
 }
}

func main() {
 ch := make(chan int, 3) // Ограниченный канал

 go producer(ch)
 consumer(ch)
}
```

### Нюансы работы с планировщиком и очередями

- **Контекст выполнения:** При использовании goroutines и каналов важно учитывать контекст выполнения. Параллельные операции могут привести к гонкам данных, если они работают с общими ресурсами без должной синхронизации.

- **Синхронизация:** Используйте механизмы синхронизации, такие как sync.WaitGroup, для управления выполнением goroutines и ожидания их завершения.

- **Производительность:** Надо отметить, что слишком много goroutines или неправильная конфигурация очередей могут привести к ухудшению производительности. Важно находить баланс.




Параллелизм и асинхронность  
Примитивы синхронизации  
Классы и интерфейсы  
Стандартные инструменты разработки  
