# DML
---
---
### Что такое DML  
DML, или Data Manipulation Language, – это подмножество SQL (Structured Query Language), которое используется для управления данными в базах данных. 

### Список команд  
В Data Manipulation Language (DML) существуют несколько ключевых команд, которые используются для работы с данными в базе данных:

- INSERT – добавляет новые записи в таблицу.
- UPDATE – обновляет существующие записи в таблице.
- DELETE – удаляет записи из таблицы.
- SELECT – извлекает данные из таблицы.
- MERGE – комбинирует операции вставки и обновления, чтобы синхронизировать данные.
   _Примеры:_
   
   ```SQL
  INSERT INTO таблица (колонка1, колонка2) VALUES (значение1, значение2);
   ```
    
   ```SQL
  UPDATE таблица SET колонка1 = значение1 WHERE условие;
   ```
   
   ```SQL
  DELETE FROM таблица WHERE условие;
   ```
   
   ```SQL
  SELECT колонка1, колонка2 FROM таблица WHERE условие;
   ```

   ```SQL
   MERGE INTO целевая_таблица USING источник ON (условие)
   WHEN MATCHED THEN UPDATE SET колонка1 = значение1
   WHEN NOT MATCHED THEN INSERT (колонка1) VALUES (значение1);
   ```
   
### Нюансы  
- **Транзакции**  
   При выполнении операций DML важно использовать транзакции для обеспечения целостности данных. Транзакции позволяют сгруппировать несколько команд в одну логическую единицу работы. Это предотвращает потерю данных в случае ошибки.

- **Проверка условий**  
   Для операций UPDATE и DELETE особенно важно правильно задавать условия. Неправильное или отсутствующее условие может привести к изменению или удалению всех записей.

- **Индексы**  
   Использование индексов может значительно улучшить производительность команд SELECT, однако может замедлить выполнения операций INSERT, UPDATE и DELETE, так как индексы необходимо обновлять.

- **Уровень изоляции**  
   Уровень изоляции транзакций влияет на видимость изменений, сделанных другими транзакциями. Различные уровни изоляции (Read Uncommitted, Read Committed, Repeatable Read, Serializable) определяют, как и когда транзакции видят изменения.

- **SQL инъекции**  
   При работе с DML важно защищать запросы от SQL инъекций. Использование параметризированных запросов и подготовленных операторов снижает риск атак.

- **Возврат ошибок**  
   Следует поймать и обработать ошибки, возникающие при выполнении DML-команд. Это поможет предотвратить неожиданное поведение приложения.

- **Обновление нескольких строк**  
   При использовании UPDATE следует помнить, что можно обновить сразу несколько строк, если условие возвращает несколько записей.

### Список вопросов с собеседования
    
# DDL
---
---

### Что такое DDL  
DDL (Data Definition Language) - это язык определения данных, который используется для описания структуры базы данных. Он включает набор команд, которые позволяют создавать, изменять и удалять структуру баз данных и их объектов.

### Список команд  
- CREATE - Используется для создания новых объектов базы данных, таких как таблицы, индексы и представления.

- ALTER - Позволяет изменять существующие объекты базы данных, такие как добавление или удаление колонок в таблице.
- DROP - Удаляет существующие объекты базы данных. Будьте осторожны, так как эта команда уничтожает все данные в объекте.
- TRUNCATE - Используется для удаления всех записей из таблицы, но структура таблицы остается. Это действие обычно быстрее, чем DELETE, потому что оно не регистрирует каждую строку.
- RENAME - Позволяет переименовывать объекты базы данных, такие как таблицы и колонки.
   _Примеры:_
   
   ```SQL
   CREATE TABLE имя_таблицы (
       колонка1 тип_данных,
       колонка2 тип_данных
   );
   ```
   
   ```SQL
  ALTER TABLE имя_таблицы ADD колонка3 тип_данных;
   ```
   
  ```SQL
  DROP TABLE имя_таблицы;
  ```
  
   ```SQL
  TRUNCATE TABLE имя_таблицы;
   ```
   
   ```SQL
  RENAME TABLE старое_имя TO новое_имя;
   ```
   
### Нюансы  
- **Проблемы с производительностью**  
Изменение структуры базы данных с большими таблицами может занять много времени и вызвать блокировки. Всегда стоит планировать операции DDL так, чтобы они выполнялись в менее загруженные часы.

- **Восстановление данных**  
Команды DDL, такие как DROP и TRUNCATE, необратимы. Важно всегда делать резервные копии критических данных перед выполнением таких операций.

- **Ограничения и зависимости**  
Когда вы изменяете структуру таблицы, необходимо учитывать зависимости, такие как внешние ключи и триггеры. Это может потребовать предварительного удаления или изменения определенных объектов.

- **Атомарные операции**  
В большинстве систем управления базами данных (СУБД) операции DDL не являются атомарными. Например, если операция изменения структуры таблицы завершится ошибкой, может возникнуть непредсказуемое состояние.

- **Индексы**  
Создание и изменение индексов с помощью DDL также может повлиять на производительность запросов. Необходимо тщательно продумывать, какие индексы необходимо создать или удалить.

- **Различия между СУБД**  
Синтаксис и возможности DDL могут различаться в зависимости от используемой СУБД (например, MySQL, PostgreSQL, SQL Server). Всегда проверяйте документацию для конкретной СУБД для получения точной информации.

- **Логи и аудит**  
Некоторые СУБД могут не записывать все операции DDL в логи. Это стоит учитывать в контексте аудита и безопасности данных.

- **Параметры безопасности**  
Управление доступом к командам DDL важно для предотвращения несанкционированных изменений в структуре базы данных. Используйте роли и привилегии для ограничения доступа.

- **Версии схемы**  
Поддержание версии схемы базы данных может быть полезным для отката изменений и отслеживания изменений на разных этапах разработки.

- **Миграции**  
Использование инструментов для управления миграциями схемы может помочь избежать проблем и значительно упростить процесс обновления структуры базы данных.

### Список вопросов с собеседования
    
# Транзакции
---
---

### Что такое транзакции  
Транзакции в SQL представляют собой последовательность операций, которые выполняются как единое целое. Транзакция обеспечивает корректность и согласованность данных в базе данных, даже в случае ошибок или сбоев.

### Основные характеристики транзакций

ACID:
- **Атомарность**  
   Все операции в транзакции выполняются полностью или не выполняются вообще. Если одна из операций завершилась неудачно, все изменения откатываются.

- **Согласованность**  
   Транзакции переводят базу данных из одного согласованного состояния в другое. Все ограничения и правила целостности данных должны соблюдаться.

- **Изолированность**  
   Изменения, сделанные в рамках одной транзакции, не видны другим транзакциям до тех пор, пока они не будут зафиксированы. Это предотвращает конфликты и несогласованность данных.

- **Долговечность**  
   После успешного завершения транзакции (фактической записи изменений), данные остаются в базе данных, даже в случае сбоя системы.

### Список команд
- BEGIN TRANSACTION – начинает новую транзакцию.
- COMMIT – зафиксировать изменения, сделанные в транзакции.
- ROLLBACK – отменить все изменения, внесенные в текущую транзакцию.

### Примеры использования
```SQL
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

Если обе операции успешны, зафиксируем транзакцию
COMMIT;

Если возникла ошибка в одной из операций, отменяем транзакцию
ROLLBACK;
```

### Нюансы
- **Уровни изоляции**
Существуют различные уровни изоляции транзакций, которые определяют, как изменения в одной транзакции могут влиять на другие. Основные уровни изоляции:

- **Время ожидания транзакции**  
Долгие транзакции могут заблокировать ресурсы и приводить к снижению производительности. Важно управлять временем ожидания транзакций, чтобы избежать ситуаций, когда одна транзакция ждет завершения другой.

- **Использование индексов**  
Индексы могут помочь улучшить производительность транзакций, особенно при сложных запросах. Однако неправильное использование индексов может привести к блокировкам и конфликтам.

- **Блокировки**  
SQL-серверы часто используют механизмы блокировок для управления конкурентным доступом к данным. Блокировки могут быть на уровне строк, страниц или объектов, и каждая из них имеет свои преимущества и недостатки.

- **Обработка ошибок**  
При выполнении транзакций важно правильно обрабатывать ошибки. Если возникает ошибка, необходимо использовать команду ROLLBACK, чтобы отменить изменения, чтобы избежать повреждения данных.


### Список вопросов с собеседования
    
# Уровни изоляции
---
---
    
### Что такое Уровни изоляции
- Уровни изоляции определяют, как транзакции взаимодействуют друг с другом и какие данные они могут видеть. 

### Виды уровней изоляции
- **Read Uncommitted**  
При этом уровне транзакции могут читать данные, измененные другими незавершенными транзакциями.  
Это может привести к "грязным чтениям", то есть к получению неконсистентных данных.

    _Пример:_

```SQL
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

- **Read Committed**  
Позволяет транзакциям читать только те данные, которые были зафиксированы.  
Это предотвращает "грязные чтения", но может возникнуть ситуация, когда данные изменятся между запросами в одной транзакции, что приведет к "неповторам".

    _Пример:_

```SQL
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

- ***Repeatable Read**  
Гарантирует, что если транзакция считывает данные несколько раз, то она всегда будет получать одни и те же результаты, если не произойдет явное изменение.  
Это предотвращает "грязные чтения" и "неповторы", однако может привести к "фантомным чтениям", когда новые строки добавляются другими транзакциями.

    _Пример:_

```SQL
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

- **Serializable**  
Самый строгий уровень изоляции, который предотвращает одновременно выполнение транзакций, делая их полностью изолированными друг от друга.  
Это обеспечивает абсолютную целостность данных, но может привести к значительным блокировкам и снижению производительности.

    _Пример:_

```SQL
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

### Нюансы
- **Выбор уровня изоляции**  
Выбор подходящего уровня изоляции зависит от конкретных требований приложения.  Например:  
    - Для отчетов, где важна производительность, может быть выбран уровень Read Uncommitted.  
    - Для обработки критических операций, где важна целостность данных, может быть выбран уровень Serializable.

- **Параллелизм и производительность**  
Высокие уровни изоляции могут привести к большему числу блокировок, что worsens производительность и может вызвать взаимные блокировки. Низкие уровни изоляции могут улучшить производительность, но увеличивают риск ошибок, связанных с целостностью данных.

- **Параметры конфигурации БД**  
Многие системы управления базами данных (СУБД) позволяют устанавливать уровень изоляции на уровне сессии или глобально для всех транзакций. Это дает возможность администраторам тонко настраивать поведение базы данных в зависимости от нагрузки и требований.

### Список вопросов с собеседования
    
# SELECT FOR UPDATE
---
---

### Что такое SELECT FOR UPDATE/SHARE
- Команда `SELECT FOR UPDATE` используется в SQL для блокировки выбранных строк во время выполнения транзакции. Это позволяет предотвратить изменения данных другими транзакциями до завершения текущей транзакции. Такой подход часто используется, когда необходимо гарантировать целостность данных при одновременном доступе.
- `SELECT FOR SHARE` – это SQL команда, используемая для выбора строк из таблицы с установлением блокировки на эти строки, чтобы другие транзакции не могли их изменять. Это позволяет гарантировать целостность данных во время выполнения длительных операций или анализа.


### Примеры использования
- Когда вы выполняете запрос с SELECT FOR UPDATE, вы:  

1. Выбираете строки из таблицы.
2. Блокируете их для других транзакций, чтобы никакие другие транзакции не могли их изменить или удалить до тех пор, пока ваша транзакция не завершится.

    _Пример запроса:_
```SQL
BEGIN;

SELECT * FROM employees
WHERE department_id = 10
FOR UPDATE;
```
- SELECT FOR SHARE

1. Простой пример выборки с блокировкой:

```sql
SELECT * FROM table_name
SELECT FOR SHARE;
```

2. Использование WITHNOLOCK для выбора строк с параллельной работой:

```sql
SELECT * FROM table_name
SELECT FOR SHARE WITH (NOLOCK);
```

### Нюансы
**SELECT FOR UPDATE:**  
- Запросы с использованием `FOR UPDATE` могут уменьшить параллелизм и производительность, так как они создают блокировки на уровне строк.
  
- Иногда необходимо использовать совместно с командами `COMMIT` или `ROLLBACK`, чтобы обеспечить корректное освобождение блокировок после завершения транзакции.  

**SELECT FOR SHARE:**  
- Блокировка на чтение: Используя `select for share`, вы устанавливаете блокировку на выбранные строки, что предотвращает их изменение другими транзакциями до окончания вашей транзакции.

- Производительность: Использование `select for share` может повлиять на производительность, так как другие транзакции будут ждать освобождения блокировки.

- Параллелизм: Механизм блокировки может ограничивать уровень параллелизма в базе данных, поэтому следует использовать эту команду осторожно.

- Системы управления базами данных: Подход может различаться в зависимости от используемой СУБД, например, PostgreSQL или Oracle могут иметь разные реализации и подходы к блокировкам.

### Список вопросов с собеседования

# Шардирование
---
---

### Что такое шардирование
- Шардирование — это метод распределения данных в реляционных базах данных, при котором данные разбиваются на более мелкие части, называемые "шарды". Каждая шард содержит часть общей базы данных и может находиться на отдельном сервере. Это позволяет улучшить производительность, масштабируемость и управляемость больших объемов данных.
  
### Список команд
- **Создание таблиц**  

Для каждой шард вы можете создать отдельные таблицы. Например:

```SQL
CREATE TABLE shard1.users (id INT PRIMARY KEY, name VARCHAR(50));
CREATE TABLE shard2.users (id INT PRIMARY KEY, name VARCHAR(50));
```


- **Вставка данных**  
В зависимости от логики шардирования, вам нужно будет направлять запросы на соответствующую шард. Например:

```SQL
INSERT INTO shard1.users (id, name) VALUES (1, 'Иван');
INSERT INTO shard2.users (id, name) VALUES (2, 'Мария');
```


- **Выбор данных**  
Выполнение запросов также будет зависеть от логики маршрутизации. Например:

```SQL
SELECT * FROM shard1.users WHERE id = 1;
SELECT * FROM shard2.users WHERE id = 2;
```


- **Партиционирвание (Partitioning)**  
Некоторые SQL базы данных поддерживают партиционирвание (partitioning), которая может помочь в шардировании:

```SQL
CREATE TABLE users (
    id INT,
    name VARCHAR(50)
)
PARTITION BY RANGE (id) (
    PARTITION p1 VALUES LESS THAN (1000),
    PARTITION p2 VALUES LESS THAN (2000)
);
```


- **Объединение данных**  
Если требуется получить данные из нескольких шаров, вам может потребоваться объединение:

```SQL
SELECT * FROM shard1.users
UNION
SELECT * FROM shard2.users;
```


- **Удаление данных**  
Управление данными в шарах может также включать команды на удаление:

```SQL
DELETE FROM shard1.users WHERE id = 1;
DELETE FROM shard2.users WHERE id = 2;
```
### Нюансы
- **Сложность**
Шардирование требует дополнительных усилий для планирования, настройки и управления.
  
- **Сложные запросы**  
Запросы, которые требуют данных из нескольких шаров, могут быть сложными и менее эффективными.

- **Управление транзакциями**
Обеспечение целостности данных и управление транзакциями между шарами может быть сложной задачей.

### Список вопросов с собеседования

# Партиционирование
---
---

### Что такое партиционирование
- Партиционирование — это метод разделения таблицы на меньшие, более управляемые части, называемые разделами (partitions). Это помогает улучшить производительность запросов и управление данными.
  
### Список команд и виды
▎**1. Типы партиционирования**
   - Партиционирование по диапазону (Range Partitioning): Разделение данных по диапазонам значений.

```SQL
CREATE TABLE sales (
    id INT,
    amount DECIMAL(10, 2),
    sale_date DATE
)
PARTITION BY RANGE (YEAR(sale_date)) (
    PARTITION p2019 VALUES LESS THAN (2020),
    PARTITION p2020 VALUES LESS THAN (2021),
    PARTITION p2021 VALUES LESS THAN (2022)
);
```

   - Партиционирование по списку (List Partitioning): Разделение данных на основе конкретных значений.

```SQL
CREATE TABLE employees (
    id INT,
    department VARCHAR(50)
)
PARTITION BY LIST (department) (
    PARTITION p_sales VALUES ('Sales'),
    PARTITION p_marketing VALUES ('Marketing'),
    PARTITION p_hr VALUES ('HR')
);
```

   - Партиционирование по хешу (Hash Partitioning): Разделение данных на основе хеш-функции.

```SQL
CREATE TABLE orders (
    id INT,
    customer_id INT
)
PARTITION BY HASH (customer_id) PARTITIONS 4;
```


   - Партиционирование по комбинации (Composite Partitioning): Использует более одного метода партиционирования.

```SQL
CREATE TABLE transactions (
    id INT,
    amount DECIMAL(10, 2),
    transaction_date DATE
)
PARTITION BY RANGE (YEAR(transaction_date))
SUBPARTITION BY HASH (amount) (
    PARTITION p2020 VALUES LESS THAN (2021) (
        SUBPARTITION s1,
        SUBPARTITION s2
    ),
    PARTITION p2021 VALUES LESS THAN (2022) (
        SUBPARTITION s3,
        SUBPARTITION s4
    )
);
```


▎**2. Управление партициями**

   - Добавление партиций:

```SQL
ALTER TABLE sales ADD PARTITION (PARTITION p2022 VALUES LESS THAN (2023));
```

   - Удаление партиций:

```SQL
ALTER TABLE sales DROP PARTITION p2019;
```

   - Просмотр информации о партициях:

```SQL
SELECT * FROM information_schema.partitions WHERE table_name = 'sales';
```

### Нюансы
1. **Выбор столбца для партиционирования**  
    - Важно выбирать правильный столбец для партиционирования, чтобы запросы могли эффективно использовать партиции.
    - Столбцы, часто используемые в условиях фильтрации, являются хорошими кандидатами.

2. **Балансировка нагрузки**  
    - Необходимо следить за тем, чтобы партиции были сбалансированы по размеру и количеству данных.
    - Неравномерные партиции могут привести к снижению производительности, так как серверу придется обрабатывать более крупные партиции дольше.

3. **Ограничения на партиционирование**  
    - В различных СУБД существуют свои ограничения по количеству партиций (например, MySQL ограничивает количество партиций для таблиц до 1024).
    - Некоторые типы индексов или агрегатных функций не могут работать с партиционированными таблицами так же, как с обычными.

4. **Использование индексов**  
    - Создание индексов на партиционированных таблицах может быть сложнее, так как индексы могут быть локальными (только на конкретной партиции) или глобальными (на все партиции).
    - Локальные индексы чаще всего производительнее для операций, затрагивающих отдельные партиции.

5. **Обновление и удаление данных**  
    - Операции обновления и удаления данных могут повлиять на производительность на партиционированных таблицах.
    - Если данные перемещаются между партициями, это может вызвать дополнительные накладные расходы.

6. **Переход к новой партиции**  
    - Нужно продумывать стратегию перехода к новым партициям, например при использовании партиционирования по времени, переход на следующий год может потребовать добавления новой партиции и удаления старой.

7. **Настройки статистики**  
    - Некоторые системы управления базами данных требуют дополнительных настроек статистики для эффективного планирования запросов на партиционированных таблицах.
    - Регулярное обновление статистики поможет поддерживать высокую производительность.

### Список вопросов с собеседования

# Репликация
---
---

### Что такое Репликация
- Репликация в SQL — это процесс копирования и поддержания объектов базы данных (таких как таблицы и их данные) между разными базами данных. Она используется для повышения доступности и надежности данных, а также для горизонтального масштабирования.

### Типы репликации
1. **Синхронная репликация:**
    - В этой модели изменения данных в основной базе данных автоматически копируются в реплицированные базы данных в реальном времени.
    - Достоинство: высокая согласованность данных.
    - Недостаток: возможны задержки при записи данных.

2. **Асинхронная репликация:**
    - Изменения в основной базе данных отправляются в реплицированные базы данных с некоторой задержкой.
    - Достоинство: высокая производительность и меньшая нагрузка на сеть.
    - Недостаток: возможность несоответствия данных между основными и реплицированными базами.

### Направления репликации
1. **Мастер-слейв:**
    - В этой схеме одна база (мастер) принимает записи, а одна или несколько других (слейвы) просто копируют данные.
    - Слейвы могут выполнять операции чтения, что позволяет разгрузить основной сервер.

2. **Мастер-мастера:**
    - В этой модели несколько баз данных могут принимать записи и синхронизироваться друг с другом.
     - Потребляет больше ресурсов, так как необходимо разрешать конфликты между записями.

### Нюансы
1. **Конфликты данных**  
При репликации могут возникать конфликты, особенно в системах с записью на нескольких узлах. Это может быть вызвано:

    - Совместными обновлениями одной и той же записи на разных серверах.
    - Различными временными зонами и местоположениями серверов.

Важно реализовать логику обработки конфликтов, чтобы избежать потери данных.

2. **Производительность**  
Репликация может влиять на производительность как мастера, так и слейва. Нюансы включают:

    - Увеличение нагрузки на сеть: Размещение больших объемов данных между мастером и слейвом может привести к задержкам.
    - Нагрузка на процессор: При асинхронной репликации совпадение данных может потребовать дополнительных ресурсов.

3. **Мониторинг и управление**  
Репликация требует постоянного мониторинга состояния серверов. Следует использовать:

    - Инструменты для отслеживания задержек репликации.
    - Настройки алертов для уведомления о сбоях.

4. **Безопасность**  
Использование безопасных соединений между мастером и слейвом имеет ключевое значение для защиты данных. Нюансы безопасности включают:

    - Шифрование данных во время передачи (например, с использованием SSL).
    - Настройки доступа и аутентификации для пользователей репликации.

5. **Обновления и изменения структуры**  
При изменении структуры базы данных (например, добавлении новых таблиц или изменении столбцов) нужно учитывать, как эти изменения будут реплицироваться. Это может потребовать:

    - Пересоздание публикаций и подписок.
    - Проверку совместимости изменений на слейве.

### Список вопросов с собеседования

# Отпимизация SQL запросов
---
---

### Что такое Отпимизация SQL запросов
Оптимизация SQL запросов — это процесс улучшения эффективности SQL-запросов для достижения:
    - Более быстрого выполнения запросов.
    - Снижения нагрузки на сервер базы данных.
    - Экономии ресурсов системы, таких как память и процессор.
      
### Список команд
- **explain/analyze/explain analyze**  
Используйте команду `EXPLAIN`, чтобы получить информацию о том, как будет выполняться ваш запрос. Это поможет понять, какие индексы используются и как выполняется соединение таблиц. 

    _Пример:_

```sql
CREATE TABLE foo (c1 integer, c2 text);
INSERT INTO foo
  SELECT i, md5(random()::text)
  FROM generate_series(1, 1000000) AS i;
```  
Попробуем прочитать данные  

```sql
EXPLAIN SELECT * FROM foo;
```  
Результат:

```sql
QUERY PLAN
— Seq Scan on foo (cost=0.00..18334.00 rows=1000000 width=37)
(1 row)
```  

В нашем случае `EXPLAIN` сообщает, что используется `Seq Scan` — последовательное, блок за блоком, чтение данных таблицы `foo`.  
Что такое `cost`? Это не время, а некое сферическое в вакууме понятие, призванное оценить затратность операции. Первое значение 0.00 — затраты на получение первой строки. Второе — 18334.00 — затраты на получение всех строк.  
`rows` — приблизительное количество возвращаемых строк при выполнении операции `Seq Scan`. Это значение возвращает планировщик. В нашем случае оно совпадает с реальным количеством строк в таблице.  
`width` — средний размер одной строки в байтах.  

Попробуем добавить 10 строк.  

```sql
INSERT INTO foo
  SELECT i, md5(random()::text)
  FROM generate_series(1, 10) AS i;
EXPLAIN SELECT * FROM foo;
```
Результат:  
```sql
QUERY PLAN
— Seq Scan on foo (cost=0.00..18334.00 rows=1000000 width=37)
(1 row)
```
Значение `rows` не изменилось. Статистика по таблице старая. Для обновления статистики вызываем команду `ANALYZE`.

```sql
ANALYZE foo;
EXPLAIN SELECT * FROM foo;
```
Результат:  
```sql
QUERY PLAN
— Seq Scan on foo (cost=0.00..18334.10 rows=1000010 width=37)
(1 row)
```
Теперь `rows` отображает правильное количество строк.  

Что происходит при выполнении `ANALYZE`?  

Считывается определённое количество строк таблицы, выбранных случайным образом
Собирается статистика значений по каждой из колонок таблицы:  

Сколько строк будет считывать `ANALYZE` — зависит от параметра `default_statistics_target`.  

**Реальные данные**  

Всё, что мы видели выше в выводе команды `EXPLAIN` — только ожидания планировщика. Попробуем сверить их с результатами на реальных данных. Используем `EXPLAIN (ANALYZE)` .

```sql
EXPLAIN (ANALYZE) SELECT * FROM foo;
```
Результат:  
```sql
QUERY PLAN
— Seq Scan on foo (cost=0.00..18334.10 rows=1000010 width=37) (actual time=0.012..61.524 rows=1000010 loops=1)
Total runtime: 90.944 ms
(2 rows)
```
Такой запрос будет исполняется реально. Так что если вы выполняете `EXPLAIN (ANALYZE)` для `INSERT`, `DELETE` или `UPDATE`, ваши данные изменятся. Будьте внимательны! В таких случаях используйте команду `ROLLBACK`.  
В выводе команды информации добавилось.  
`actual time` — реальное время в миллисекундах, затраченное для получения первой строки и всех строк соответственно.  
`rows` — реальное количество строк, полученных при `Seq Scan`.  
`loops` — сколько раз пришлось выполнить операцию `Seq Scan`.  
`Total runtime` — общее время выполнения запроса.  

### Способы оптимизации запросов

1. **Индексы**  
Создание индексов для ускорения поиска:

    _Пример:_

```SQL
CREATE INDEX index_name ON table(column);
```

2. **Использование JOIN вместо подзапросов**  
В некоторых случаях правильное использование JOIN может быть более эффективным, чем использование подзапросов:

    _Пример:_

```SQL
SELECT a.column1, b.column2
FROM table_a a
JOIN table_b b ON a.id = b.a_id;
```

3. **Ограничение выборки с помощью LIMIT**  
Если вам нужно только несколько записей, используйте LIMIT для снижения нагрузки на сервер:

    _Пример:_

```SQL
SELECT column1, column2 FROM table WHERE condition LIMIT 10;
```

4. **Удаление лишних данных с помощью WHERE**
Фильтруйте результаты на этапе запроса, чтобы избежать ненужных данных:

    _Пример:_

```SQL
SELECT column1, column2 FROM table WHERE condition;
```

5. **Использование агрегатных функций**
Постарайтесь использовать агрегатные функции, чтобы обрабатывать данные на стороне базы данных, а не на клиенте:

    _Пример:_

```SQL
SELECT COUNT(*), AVG(column) FROM table WHERE condition;
```

### Нюансы
1. **Индексы**  
Хотя индексы могут значительно ускорить работу с данными, их чрезмерное использование может замедлить операции вставки и обновления. Нужно находить баланс.

2. **Выбор типов данных**  
Используйте подходящие типы данных для колонок. Например, вместо использования `VARCHAR` для хранения дат лучше использовать тип `DATE`.

3. **Анализ выполнения запросов**  
Регулярно проверяйте, как выполняются ваши запросы с помощью `EXPLAIN` или утилит анализа, чтобы выявлять узкие места.

4. **Условия фильтрации**  
Старайтесь помещать наиболее селективные условия (условия, которые отфильтровывают больше всего данных) в начало `WHERE`-клаузы. Это может улучшить производительность.

5. **Избегание `SELECT *`**  
Избегайте использования `SELECT *`. Лучше указывайте только необходимые колонки, чтобы уменьшить объем передаваемых данных:

```SQL
SELECT column1, column2 FROM table WHERE condition;
```

6. **Правильное использование `JOIN`**  
Понимание типов соединений (`INNER, LEFT, RIGHT`) и их последствий поможет избежать избыточных данных. Оценивайте, какие соединения действительно нужны.

7. **Поддержка индексов**  
Регулярно пересматривайте и обновляйте индексы, особенно после массовых вставок или изменений данных.

8. **Параметризация запросов**  
Используйте параметризированные запросы для предотвращения SQL-инъекций и улучшения производительности за счет повторного использования плана выполнения.

9. **Мониторинг системных ресурсов**  
Следите за использованием ресурсов (памяти, CPU) сервером базы данных и базами данных, что может помочь выявить проблемы с производительностью.

### Список вопросов с собеседования

# pg_stat
---
---

### Что такое pg_stat

- pg_stat — это представление в PostgreSQL, которое содержит статистические данные о различных объектах и деятельности системы. Оно помогает администраторам и разработчикам отслеживать производительность и активность базы данных.

### Описание  

Модуль pg_stat предоставляет информацию о:  

- Активных сессиях и их состоянии.
- Статистике запросов, таких как количество выполненных запросов, время выполнения и блокировки.
- Использовании индексов и таблиц.
- Показателях работы серверов и различных компонентов базы данных.  

К основным представлениям pg_stat относятся:  

- `pg_stat_activity`: показывает текущие активные процессы и запросы.
- `pg_stat_user_tables`: содержит статистику для всех пользовательских таблиц.
- `pg_stat_user_indexes`: содержит информацию о пользовательских индексах.
- `pg_stat_database`: предоставляет данные по активности и производительности для каждой базы данных.

### Примеры

1. Просмотр активных сессий:  

```sql
SELECT * FROM pg_stat_activity;
```  

Этот запрос вернет список всех активных сессий, включая информацию о запрашивающем процессе, времени начала и состоянии.  

2. Статистика по таблицам:  

```sql
SELECT * FROM pg_stat_user_tables;
```  

Этот запрос отобразит статистику по всем пользовательским таблицам, включая количество вставок, обновлений, удалений и т.д.  

3. Статистика по индексам:  

```sql
SELECT * FROM pg_stat_user_indexes;
```  

Этот запрос покажет статистику по индексам, включая количество использований и блокировок.  

4. Статистика по базам данных:  

```sql
SELECT * FROM pg_stat_database;
```  

Этот запрос предоставит обобщенную информацию о всех базах данных, например, о числе подключений и объеме данных, записанных в журнал.  

### Нюансы

- Права доступа: Для доступа к представлениям `pg_stat` может потребоваться соответствующие привилегии. Например, не все пользователи могут видеть статистику для всех баз данных или сессий.

- Обновление статистики: Статистические данные обновляются в процессе работы базы данных, и значения могут изменяться в режиме реального времени.

- Влияние на производительность: Избыточное использование представлений `pg_stat`, особенно на больших системах, может оказывать влияние на производительность. Поэтому рекомендуется использовать их с осторожностью.

# CAP теорема
---
---

### Что такое CAP теорема

CAP теорема, также известная как теорема Брэйера, касается распределенных компьютерных систем и формулирует три основных свойства, которые нельзя одновременно удовлетворить:  
- Consistency (Согласованность)
- Availability (Доступность)
- Partition Tolerance (Терпимость к разделению)  

Согласно этой теореме, в условиях сетевых разделений всегда необходимо жертвовать одним из этих свойств.

### Описание

- **Согласованность (C)**: Все узлы системы видят одни и те же данные в одно и то же время. Если некоторый узел получает обновление данных, то все остальные узлы должны видеть это обновление до того, как будет выполнен следующий запрос к данным.

- **Доступность (A)**: Каждое запрашиваемое хранилище данных всегда отвечает на запрос, даже если данные могут быть устаревшими или несогласованными.

- **Терпимость к разделению (P)**: Система продолжает функционировать, даже если сеть разделена на две или более частей, и не может обмениваться сообщениями между себе.

### Примеры

1. Согласованная система:  

Системы, такие как банковские базы данных, стремятся обеспечивать высокую степень согласованности, поэтому они могут жертвовать доступностью, чтобы гарантировать, что данные остаются верными. Например, если сеть разделяется, система может перестать принимать запросы до восстановления связи.

2. Доступная система:  

Системы, такие как некоторые NoSQL базы данных (например, Cassandra или DynamoDB), могут обеспечивать высокую доступность, даже если данные могут быть не совсем согласованными. Если пользователи запрашивают данные во время разрыва сети, система продолжит отвечать, но данные могут отличаться на разных узлах.

3. Терпимые к разделениям системы:  

Большинство современных распределенных баз данных стремятся быть терпимыми к разделениям, так как они работают в условиях, когда сетевые задержки и сбои неизбежны. Они могут выбирать, как балансировать между согласованностью и доступностью в зависимости от бизнес-требований.

### Нюансы

- **Практическое применение:** В реальных приложениях системы часто решают "находиться где-то между" C и A, выбирая различные подходы. Это может означать использование алгоритмов общей множественной версии, оптимистических блокировок и других методов.

- **Понимание домена:** При проектировании распределённых систем важно учитывать требования конкретного бизнес-контекста, чтобы сделать правильный выбор относительно CAP свойств.

- **Адаптация:** Некоторые системы могут выбирать разные уровни согласованности и доступности в зависимости от сценариев использования, что может повысить эффективность и производительность.

# Первичный/вторичный ключ, составной ключ
---
---

### Первичный и вторичный ключи в SQL

- **Первичный ключ** – это уникальный идентификатор для каждой записи в таблице базы данных. Он обеспечивает целостность данных, так как не может содержать NULL-значения. Каждый первичный ключ должен быть уникальным и фиксированным для каждой строки.

- **Вторичный ключ (или внешний ключ)** – это поле, или набор полей, которые ссылаются на первичный ключ другой таблицы. Он используется для установления и управления связями между таблицами.

### Составной ключ

- **Составной ключ** – это тип ключа, который состоит из двух или более столбцов таблицы. Составной ключ используется, когда простой ключ (один столбец) не может однозначно идентифицировать запись.

### Примеры

1. Первичный ключ:  

```sql
CREATE TABLE Users (
    UserID INT PRIMARY KEY,
    UserName VARCHAR(100)
);
```  

В этом примере столбец UserID является первичным ключом таблицы Users.  

2. Вторичный ключ:  

```sql
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    UserID INT,
    FOREIGN KEY (UserID) REFERENCES Users(UserID)
);
```  

Здесь UserID в таблице Orders является внешним ключом, который связывает заказы с пользователями.  

3. Составной ключ:  

```sql
CREATE TABLE Enrollment (
    StudentID INT,
    CourseID INT,
    PRIMARY KEY (StudentID, CourseID)
);
```  

В этом примере составной ключ состоит из StudentID и CourseID. Этот ключ используется для уникальной идентификации записей в таблице Enrollment, указывая, что конкретный студент может быть записан на конкретный курс.  

### Нюансы

- **Первичный ключ:** Важно выбирать первичный ключ, который редко изменяется; изменения могут привести к нарушению целостности данных.

- **Вторичный ключ:** Они могут учитывать NULL-значения, но не могут содержать уникальных значений, если они не являются уникальными.

- **Составной ключ:** При использовании составных ключей следует учитывать количество столбцов, поскольку слишком много полей в ключе могут усложнить запросы и отрицательно сказаться на производительности.

- **Индексация:** Оба типа ключей автоматически индексируются в большинстве СУБД, что улучшает скорость поиска данных.


# Кластеризованый/некластеризованый индекс
---
---

Индексы в SQL – это структуры данных, которые улучшают скорость операций выборки из базы данных. Существует два основных типа индексов: кластеризованные и некластеризованные.

### Кластеризованный индекс

- Кластеризованный индекс определяет порядок физического хранения строк в таблице. Это означает, что данные в таблице фактически отсортированы по ключу индекса. Каждая таблица может иметь только один кластеризованный индекс, так как данные в таблице могут быть отсортированы только по одному полю или набору полей.  

_Пример:_

```sql
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    LastName VARCHAR(100),
    FirstName VARCHAR(100)
);
```  

В этом примере EmployeeID автоматически становится кластеризованным индексом, поскольку это первичный ключ. Данные в таблице Employees будут отсортированы по EmployeeID.

### Некластеризованный индекс

- Некластеризованный индекс - это индекс, который не определяет порядок хранения данных. Вместо этого он содержит указатели на физическое местоположение данных в таблице, что позволяет ускорить выборку данных по индексу, но не влияет на порядок самих строк в таблице. В одной таблице можно создать несколько некластеризованных индексов.  

_Пример:_

```sql
CREATE INDEX idx_LastName ON Employees (LastName);
```  

В этом примере создается некластеризованный индекс для столбца LastName. Этот индекс позволит быстро находить записи с определенными значениями в столбце LastName, но данные в таблице не будут изменены.

### Нюансы 

1. **Кластеризованный индекс:**  
    - Порядок хранения данных определяет индекс, поэтому операции вставки и обновления могут быть медленными, если они требуют перемещения строк для поддержания порядка.
    - Используйте кластеризованный индекс на полях, по которым часто выполняются операции выборки и сортировки.
    - Очень эффективен для диапазонных запросов, так как строки физически хранятся рядом друг с другом.

2. **Некластеризованный индекс:**  
    - Позволяет создавать несколько индексов на одной таблице, что может быть полезно для различных запросов.
    - все равно требует дополнительных операций для доступа к данным, так как нужно следовать указателям в индексе, чтобы получить доступ к самим строкам.
    - Может замедлить вставку и обновление строк, так как необходимо поддерживать отдельные структуры индексов.

3. **Выбор индекса:**  
    - При проектировании индексов важно учитывать как операции чтения, так и записи. Чтобы оптимизировать всю систему, нужно находить баланс между количеством и типами индексов.

4. **Сложные запросы:**  
    - Использование нескольких некластеризованных индексов может помочь при сложных запросах, но в некоторых случаях их компоновка может приводить к необходимости множественных операций доступа, что может снизить производительность.

# Какие типы индексов бывают по внутренней структуре (B-tree, Hash, Gist, Gin)
---
---

В SQL базах данных индексы могут быть реализованы различными способами, в зависимости от их внутренней структуры. Основные типы индексов по внутренней структуре включают B-tree, Hash, GiST и GIN.  

## B-tree индекс

B-tree индекс (сбалансированное древовидное хранилище) - это наиболее распространенный тип индекса, который обеспечивает быструю выборку данных за счет хранения данных в сбалансированном дереве. Он подходит для диапазонных запросов и поддерживает операции как равенства, так и неравенства.  

_Пример:_

```sql
CREATE INDEX idx_lastname ON Employees (LastName);
```  

### Нюансы:

- Эффективен для операций поиска, сортировки и диапазонов.
- Подходит для обработки запросов с использованием оператора BETWEEN и LIKE.
- Может немного замедлить операции вставки и обновления из-за необходимости поддерживать структуру дерева.

## Hash индекс  

Hash индекс использует хеш-функцию для быстрого поиска значений. Он подходит только для операций равенства и не поддерживает диапазонные запросы.  

_Пример:_

```sql
CREATE INDEX idx_employeeid_hash ON Employees USING HASH (EmployeeID);
```  

### Нюансы:

- Очень быстрый для поисков по равенству, но не подходит для диапазонов.
- Не позволяет использовать операторы >, <, BETWEEN и LIKE.
- Может быть неэффективен при коллизиях хешей, когда разные значения имеют одинаковый хеш.

## GiST (Generalized Search Tree)

GiST индекс - это обобщенное дерево поиска, которое позволяет хранить данные в виде объектов. Он поддерживает различные типы пользовательских типов данных и операторы, что делает его очень гибким.  

_Пример:_

```sql
CREATE INDEX idx_geom ON Locations USING GiST (geom);
```  

### Нюансы:

- Подходит для работы с геометрическими данными и многими другими типами данных.
- Позволяет строить индексы для сложных данных, например, для векторных или пространственных данных.
- Производительность может варьироваться в зависимости от сложности данных и используемых операторов.

## GIN (Generalized Inverted Index)

GIN индекс - это обобщенный обратный индекс, который особенно хорошо используется для хранения и поиска неполных данных (например, массивов, JSON). Он также может эффективно работать с текстовыми полями.  

_Пример:_

```sql
CREATE INDEX idx_keywords ON Articles USING GIN (keywords);
```  

### Нюансы:

- Идеален для работы с множественными значениями внутри одного поля и текстовым поиском.
- Может занимать больше места по сравнению с GiST, особенно для большого количества уникальных значений.
- Хорошо подходит для работы с полнотекстовым поиском.

# Виртуальные шарды 
---
---

Виртуальные шарды - это концепция, применяемая в распределенных системах управления базами данных, которая позволяет разделять данные на части (шарды) и распределять их по различным физическим или логическим хранилищам. Виртуальные шарды создают абстракцию, позволяющую пользователю взаимодействовать с данными так, как если бы они находились в одной базе данных, при этом обеспечивая масштабируемость и улучшение производительности.

### Описание  

Виртуальные шарды обеспечивают:  

1. Горизонтальное масштабирование: Разделение данных на шарды позволяет масштабировать систему путем добавления новых узлов, которые могут хранить дополнительные шардированные данные.

2. Управление нагрузкой: Данные могут равномерно распределяться по шардам для снижения нагрузки на единичные узлы, что помогает избежать узких мест при обработке запросов.

3. Упрощение архитектуры: Виртуальные шарды могут скрывать сложность распределенного хранения данных, предоставляя единый интерфейс для выполнения запросов.

### Примеры

1. **Shard by User ID:** Можно создать виртуальные шарды, разделив данные пользователей по диапазонам идентификаторов. Например, пользователи с `UserID` от 1 до 1000 находятся в одном шард, от 1001 до 2000 – в другом.

```sql
SELECT * FROM Users WHERE UserID BETWEEN 1 AND 1000; -- Запрос к первому шард
```

2. **Shard by Geography:** Виртуальные шарды также могут использоваться для географического распределения данных. Например, данные пользователей из разных регионов могут храниться в отдельных шардах.  

Запрос данных из северного региона:  
```sql
SELECT * FROM Users WHERE Region = 'North';
```

### Нюансы

- **Сложность реализации:** Внедрение виртуальных шардов требует дополнительных усилий, чтобы управлять распределением данных и маршрутизацией запросов.

- **Балансировка нагрузки:** Необходима внимательная настройка шардирования, чтобы избежать неравномерного распределения данных, что может привести к проблемам с производительностью.

- **Управление транзакциями:** Обработка транзакций становится более сложной в распределенной среде, что может потребовать использования нескольких стратегий управления в зависимости от конфигурации шардирования.

- **Вертикальная и горизонтальная практика:** Необходимо учитывать, что шардирование не является единственным способом управления данными. Иногда существует необходимость в вертикальном разделении данных (то есть делении по таблицам или колонкам), что может использоваться вместе с шардированием.

# Виртуальные колонки
---
---

- **Виртуальные колонки (или вычисляемые колонки)** — это колонки, значения которых не хранятся в базе данных, а вычисляются при выполнении запроса. Они могут быть полезны для оптимизации работы с данными, позволяя избежать дублирования информации и обеспечивая динамическое создание значений на основе других колонок.

### Описание

Виртуальные колонки:  

1. Не заносят данные на диск: Значения виртуальных колонок не сохраняются в таблице, поэтому их размер не увеличивает пространство, занимаемое таблицей.

2. Вычисляемые в реальном времени: Зависимые от других колонок и создаются на основе заданной формулы или выражения при запросе.

3. Упрощают запросы: Позволяют не создавать дополнительные таблицы или столбцы для хранения производных данных, что упрощает логику запросов.

### Примеры

1. Вычисление полной цены: Пусть у нас есть таблица Products с колонками Price и TaxRate, и мы хотим добавить виртуальную колонку TotalPrice, которая будет вычислять полную цену продукта с учетом налога.  

```sql
CREATE TABLE Products (
    ProductID INT,
    Price DECIMAL(10, 2),
    TaxRate DECIMAL(5, 2),
    TotalPrice AS (Price + (Price * TaxRate)) -- Виртуальная колонка
);
```

2. Форматирование данных: Виртуальная колонка может быть использована для форматирования данных, например, для создания полного имени из колонок FirstName и LastName.  

```sql
CREATE TABLE Employees (
    EmployeeID INT,
    FirstName VARCHAR(50),
    LastName VARCHAR(50),
    FullName AS (FirstName + ' ' + LastName) -- Виртуальная колонка
);
```

### Нюансы

- **Производительность:** Хотя виртуальные колонки могут улучшить управление данными, вычисление значений в реальном времени может негативно сказаться на производительности при выполнении сложных запросов с большим объемом данных.

- **Отсутствие индексации:** В многих системах управления базами данных виртуальные колонки не могут индексироваться, что может привести к замедлению выполнения запросов.

- **Сложные выражения:** Использование сложных формул и логики в виртуальных колонках может усложнить понимание и поддержку структуры таблицы.

- **Не поддерживают все СУБД:** Не все системы управления базами данных поддерживают виртуальные колонки. Например, в некоторых версиях MySQL это реализовано, в других нет. Перед использованием следует ознакомиться с документацией вашей СУБД.

# Материализация
---
---

- **Материализация** — это процесс, в котором результаты выполнения запроса сохраняются в виде отдельной физической таблицы, называемой материализованным представлением. Это может существенно повысить производительность запросов, особенно на больших объемах данных, так как позволяет избежать повторного выполнения сложных операций выборки.

### Описание

Материализация характеризуется следующими аспектами:  

1. **Сохранение данных:** В отличие от обычного представления, которое вычисляется при каждом обращении, материализованное представление хранит результаты, что позволяет обращаться к ним значительно быстрее.

2. **Обновление данных:** Материализованные представления могут требовать регулярного обновления для синхронизации с исходными данными, что можно осуществлять либо вручную, либо автоматически по расписанию.

3. **Применение для аналитики:** Материализация часто используется в аналитических системах, где время ответа критически важно, и требуется работа с предварительно обработанными данными.

### Примеры

1. Создание материализованного представления: Предположим, у нас есть таблицы Sales и Products, и мы хотим создать материализованное представление для суммарных продаж по продуктам.  

```sql
CREATE MATERIALIZED VIEW SalesSummary AS
SELECT ProductID, SUM(Amount) AS TotalSales
FROM Sales
GROUP BY ProductID;
```  

2. Обновление материализованного представления: Обновление представления можно выполнить по мере необходимости, чтобы синхронизировать данные.  

```sql
REFRESH MATERIALIZED VIEW SalesSummary;
```  

### Нюансы

- **Использование места:** Материализованные представления занимают место в базе данных, поскольку хранят копии данных. Это может быть значительным при работе с большими датасетами.

- **Задержка обновления:** Существует риск, что материализованные представления будут содержать устаревшую информацию, потому что они не обновляются в реальном времени.

- **Мониторинг производительности:** При использовании материализованных представлений необходимо следить за производительностью базы данных, так как обновление представлений может влиять на скорость работы системы.

- **Поддержка СУБД:** Не все системы управления базами данных поддерживают материализованные представления, или их реализация может различаться. Важно ознакомиться с документацией вашей СУБД перед использованием.























