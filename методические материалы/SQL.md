# DML
---
---
### Что такое DML  
DML, или Data Manipulation Language, – это подмножество SQL (Structured Query Language), которое используется для управления данными в базах данных. 

### Список команд  
В Data Manipulation Language (DML) существуют несколько ключевых команд, которые используются для работы с данными в базе данных:

- INSERT – добавляет новые записи в таблицу.
- UPDATE – обновляет существующие записи в таблице.
- DELETE – удаляет записи из таблицы.
- SELECT – извлекает данные из таблицы.
- MERGE – комбинирует операции вставки и обновления, чтобы синхронизировать данные.
   _Примеры:_
   
   ```SQL
  INSERT INTO таблица (колонка1, колонка2) VALUES (значение1, значение2);
   ```
    
   ```SQL
  UPDATE таблица SET колонка1 = значение1 WHERE условие;
   ```
   
   ```SQL
  DELETE FROM таблица WHERE условие;
   ```
   
   ```SQL
  SELECT колонка1, колонка2 FROM таблица WHERE условие;
   ```

   ```SQL
   MERGE INTO целевая_таблица USING источник ON (условие)
   WHEN MATCHED THEN UPDATE SET колонка1 = значение1
   WHEN NOT MATCHED THEN INSERT (колонка1) VALUES (значение1);
   ```
   
### Нюансы  
- **Транзакции**  
   При выполнении операций DML важно использовать транзакции для обеспечения целостности данных. Транзакции позволяют сгруппировать несколько команд в одну логическую единицу работы. Это предотвращает потерю данных в случае ошибки.

- **Проверка условий**  
   Для операций UPDATE и DELETE особенно важно правильно задавать условия. Неправильное или отсутствующее условие может привести к изменению или удалению всех записей.

- **Индексы**  
   Использование индексов может значительно улучшить производительность команд SELECT, однако может замедлить выполнения операций INSERT, UPDATE и DELETE, так как индексы необходимо обновлять.

- **Уровень изоляции**  
   Уровень изоляции транзакций влияет на видимость изменений, сделанных другими транзакциями. Различные уровни изоляции (Read Uncommitted, Read Committed, Repeatable Read, Serializable) определяют, как и когда транзакции видят изменения.

- **SQL инъекции**  
   При работе с DML важно защищать запросы от SQL инъекций. Использование параметризированных запросов и подготовленных операторов снижает риск атак.

- **Возврат ошибок**  
   Следует поймать и обработать ошибки, возникающие при выполнении DML-команд. Это поможет предотвратить неожиданное поведение приложения.

- **Обновление нескольких строк**  
   При использовании UPDATE следует помнить, что можно обновить сразу несколько строк, если условие возвращает несколько записей.

### Список вопросов с собеседования
    
# DDL
---
---

### Что такое DDL  
DDL (Data Definition Language) - это язык определения данных, который используется для описания структуры базы данных. Он включает набор команд, которые позволяют создавать, изменять и удалять структуру баз данных и их объектов.

### Список команд  
- CREATE - Используется для создания новых объектов базы данных, таких как таблицы, индексы и представления.

- ALTER - Позволяет изменять существующие объекты базы данных, такие как добавление или удаление колонок в таблице.
- DROP - Удаляет существующие объекты базы данных. Будьте осторожны, так как эта команда уничтожает все данные в объекте.
- TRUNCATE - Используется для удаления всех записей из таблицы, но структура таблицы остается. Это действие обычно быстрее, чем DELETE, потому что оно не регистрирует каждую строку.
- RENAME - Позволяет переименовывать объекты базы данных, такие как таблицы и колонки.
   _Примеры:_
   
   ```SQL
   CREATE TABLE имя_таблицы (
       колонка1 тип_данных,
       колонка2 тип_данных
   );
   ```
   
   ```SQL
  ALTER TABLE имя_таблицы ADD колонка3 тип_данных;
   ```
   
  ```SQL
  DROP TABLE имя_таблицы;
  ```
  
   ```SQL
  TRUNCATE TABLE имя_таблицы;
   ```
   
   ```SQL
  RENAME TABLE старое_имя TO новое_имя;
   ```
   
### Нюансы  
- **Проблемы с производительностью**  
Изменение структуры базы данных с большими таблицами может занять много времени и вызвать блокировки. Всегда стоит планировать операции DDL так, чтобы они выполнялись в менее загруженные часы.

- **Восстановление данных**  
Команды DDL, такие как DROP и TRUNCATE, необратимы. Важно всегда делать резервные копии критических данных перед выполнением таких операций.

- **Ограничения и зависимости**  
Когда вы изменяете структуру таблицы, необходимо учитывать зависимости, такие как внешние ключи и триггеры. Это может потребовать предварительного удаления или изменения определенных объектов.

- **Атомарные операции**  
В большинстве систем управления базами данных (СУБД) операции DDL не являются атомарными. Например, если операция изменения структуры таблицы завершится ошибкой, может возникнуть непредсказуемое состояние.

- **Индексы**  
Создание и изменение индексов с помощью DDL также может повлиять на производительность запросов. Необходимо тщательно продумывать, какие индексы необходимо создать или удалить.

- **Различия между СУБД**  
Синтаксис и возможности DDL могут различаться в зависимости от используемой СУБД (например, MySQL, PostgreSQL, SQL Server). Всегда проверяйте документацию для конкретной СУБД для получения точной информации.

- **Логи и аудит**  
Некоторые СУБД могут не записывать все операции DDL в логи. Это стоит учитывать в контексте аудита и безопасности данных.

- **Параметры безопасности**  
Управление доступом к командам DDL важно для предотвращения несанкционированных изменений в структуре базы данных. Используйте роли и привилегии для ограничения доступа.

- **Версии схемы**  
Поддержание версии схемы базы данных может быть полезным для отката изменений и отслеживания изменений на разных этапах разработки.

- **Миграции**  
Использование инструментов для управления миграциями схемы может помочь избежать проблем и значительно упростить процесс обновления структуры базы данных.

### Список вопросов с собеседования
    
# Транзакции
---
---

### Что такое транзакции  
Транзакции в SQL представляют собой последовательность операций, которые выполняются как единое целое. Транзакция обеспечивает корректность и согласованность данных в базе данных, даже в случае ошибок или сбоев.

### Основные характеристики транзакций

ACID:
- **Атомарность**  
   Все операции в транзакции выполняются полностью или не выполняются вообще. Если одна из операций завершилась неудачно, все изменения откатываются.

- **Согласованность**  
   Транзакции переводят базу данных из одного согласованного состояния в другое. Все ограничения и правила целостности данных должны соблюдаться.

- **Изолированность**  
   Изменения, сделанные в рамках одной транзакции, не видны другим транзакциям до тех пор, пока они не будут зафиксированы. Это предотвращает конфликты и несогласованность данных.

- **Долговечность**  
   После успешного завершения транзакции (фактической записи изменений), данные остаются в базе данных, даже в случае сбоя системы.

### Список команд
- BEGIN TRANSACTION – начинает новую транзакцию.
- COMMIT – зафиксировать изменения, сделанные в транзакции.
- ROLLBACK – отменить все изменения, внесенные в текущую транзакцию.

### Примеры использования
```SQL
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

Если обе операции успешны, зафиксируем транзакцию
COMMIT;

Если возникла ошибка в одной из операций, отменяем транзакцию
ROLLBACK;
```

### Нюансы
- **Уровни изоляции**
Существуют различные уровни изоляции транзакций, которые определяют, как изменения в одной транзакции могут влиять на другие. Основные уровни изоляции:

- **Время ожидания транзакции**  
Долгие транзакции могут заблокировать ресурсы и приводить к снижению производительности. Важно управлять временем ожидания транзакций, чтобы избежать ситуаций, когда одна транзакция ждет завершения другой.

- **Использование индексов**  
Индексы могут помочь улучшить производительность транзакций, особенно при сложных запросах. Однако неправильное использование индексов может привести к блокировкам и конфликтам.

- **Блокировки**  
SQL-серверы часто используют механизмы блокировок для управления конкурентным доступом к данным. Блокировки могут быть на уровне строк, страниц или объектов, и каждая из них имеет свои преимущества и недостатки.

- **Обработка ошибок**  
При выполнении транзакций важно правильно обрабатывать ошибки. Если возникает ошибка, необходимо использовать команду ROLLBACK, чтобы отменить изменения, чтобы избежать повреждения данных.


### Список вопросов с собеседования
    
# Уровни изоляции
---
---
    
### Что такое Уровни изоляции
- Уровни изоляции определяют, как транзакции взаимодействуют друг с другом и какие данные они могут видеть. 

### Виды уровней изоляции
- **Read Uncommitted**  
При этом уровне транзакции могут читать данные, измененные другими незавершенными транзакциями.  
Это может привести к "грязным чтениям", то есть к получению неконсистентных данных.

    _Пример:_

```SQL
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

- **Read Committed**  
Позволяет транзакциям читать только те данные, которые были зафиксированы.  
Это предотвращает "грязные чтения", но может возникнуть ситуация, когда данные изменятся между запросами в одной транзакции, что приведет к "неповторам".

    _Пример:_

```SQL
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

- ***Repeatable Read**  
Гарантирует, что если транзакция считывает данные несколько раз, то она всегда будет получать одни и те же результаты, если не произойдет явное изменение.  
Это предотвращает "грязные чтения" и "неповторы", однако может привести к "фантомным чтениям", когда новые строки добавляются другими транзакциями.

    _Пример:_

```SQL
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

- **Serializable**  
Самый строгий уровень изоляции, который предотвращает одновременно выполнение транзакций, делая их полностью изолированными друг от друга.  
Это обеспечивает абсолютную целостность данных, но может привести к значительным блокировкам и снижению производительности.

    _Пример:_

```SQL
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

### Нюансы
- **Выбор уровня изоляции**  
Выбор подходящего уровня изоляции зависит от конкретных требований приложения.  Например:  
    - Для отчетов, где важна производительность, может быть выбран уровень Read Uncommitted.  
    - Для обработки критических операций, где важна целостность данных, может быть выбран уровень Serializable.

- **Параллелизм и производительность**  
Высокие уровни изоляции могут привести к большему числу блокировок, что worsens производительность и может вызвать взаимные блокировки. Низкие уровни изоляции могут улучшить производительность, но увеличивают риск ошибок, связанных с целостностью данных.

- **Параметры конфигурации БД**  
Многие системы управления базами данных (СУБД) позволяют устанавливать уровень изоляции на уровне сессии или глобально для всех транзакций. Это дает возможность администраторам тонко настраивать поведение базы данных в зависимости от нагрузки и требований.

### Список вопросов с собеседования
    
# SELECT FOR UPDATE
---
---

### Что такое SELECT FOR UPDATE/SHARE
- Команда SELECT FOR UPDATE используется в SQL для блокировки выбранных строк во время выполнения транзакции. Это позволяет предотвратить изменения данных другими транзакциями до завершения текущей транзакции. Такой подход часто используется, когда необходимо гарантировать целостность данных при одновременном доступе.

### Примеры использования
- Когда вы выполняете запрос с SELECT FOR UPDATE, вы:  

1. Выбираете строки из таблицы.
2. Блокируете их для других транзакций, чтобы никакие другие транзакции не могли их изменить или удалить до тех пор, пока ваша транзакция не завершится.

    _Пример запроса:_
```SQL
BEGIN;

SELECT * FROM employees
WHERE department_id = 10
FOR UPDATE;
```

### Нюансы
- Запросы с использованием FOR UPDATE могут уменьшить параллелизм и производительность, так как они создают блокировки на уровне строк.
  
- Иногда необходимо использовать совместно с командами COMMIT или ROLLBACK, чтобы обеспечить корректное освобождение блокировок после завершения транзакции.

### Список вопросов с собеседования

# Шардирование
---
---

### Что такое шардирование
- Шардирование — это метод распределения данных в реляционных базах данных, при котором данные разбиваются на более мелкие части, называемые "шарды". Каждая шард содержит часть общей базы данных и может находиться на отдельном сервере. Это позволяет улучшить производительность, масштабируемость и управляемость больших объемов данных.
  
### Список команд
- **Создание таблиц**  

Для каждой шард вы можете создать отдельные таблицы. Например:

```SQL
CREATE TABLE shard1.users (id INT PRIMARY KEY, name VARCHAR(50));
CREATE TABLE shard2.users (id INT PRIMARY KEY, name VARCHAR(50));
```


- **Вставка данных**  
В зависимости от логики шардирования, вам нужно будет направлять запросы на соответствующую шард. Например:

```SQL
INSERT INTO shard1.users (id, name) VALUES (1, 'Иван');
INSERT INTO shard2.users (id, name) VALUES (2, 'Мария');
```


- **Выбор данных**  
Выполнение запросов также будет зависеть от логики маршрутизации. Например:

```SQL
SELECT * FROM shard1.users WHERE id = 1;
SELECT * FROM shard2.users WHERE id = 2;
```


- **Партиционирвание (Partitioning)**  
Некоторые SQL базы данных поддерживают партиционирвание (partitioning), которая может помочь в шардировании:

```SQL
CREATE TABLE users (
    id INT,
    name VARCHAR(50)
)
PARTITION BY RANGE (id) (
    PARTITION p1 VALUES LESS THAN (1000),
    PARTITION p2 VALUES LESS THAN (2000)
);
```


- **Объединение данных**  
Если требуется получить данные из нескольких шаров, вам может потребоваться объединение:

```SQL
SELECT * FROM shard1.users
UNION
SELECT * FROM shard2.users;
```


- **Удаление данных**  
Управление данными в шарах может также включать команды на удаление:

```SQL
DELETE FROM shard1.users WHERE id = 1;
DELETE FROM shard2.users WHERE id = 2;
```
### Нюансы
- **Сложность**
Шардирование требует дополнительных усилий для планирования, настройки и управления.
  
- **Сложные запросы**  
Запросы, которые требуют данных из нескольких шаров, могут быть сложными и менее эффективными.

- **Управление транзакциями**
Обеспечение целостности данных и управление транзакциями между шарами может быть сложной задачей.

### Список вопросов с собеседования

# Партиционирование
---
---

### Что такое партиционирование
- Партиционирование — это метод разделения таблицы на меньшие, более управляемые части, называемые разделами (partitions). Это помогает улучшить производительность запросов и управление данными.
  
### Список команд и виды
▎**1. Типы партиционирования**
   - Партиционирование по диапазону (Range Partitioning): Разделение данных по диапазонам значений.

```SQL
CREATE TABLE sales (
    id INT,
    amount DECIMAL(10, 2),
    sale_date DATE
)
PARTITION BY RANGE (YEAR(sale_date)) (
    PARTITION p2019 VALUES LESS THAN (2020),
    PARTITION p2020 VALUES LESS THAN (2021),
    PARTITION p2021 VALUES LESS THAN (2022)
);
```

   - Партиционирование по списку (List Partitioning): Разделение данных на основе конкретных значений.

```SQL
CREATE TABLE employees (
    id INT,
    department VARCHAR(50)
)
PARTITION BY LIST (department) (
    PARTITION p_sales VALUES ('Sales'),
    PARTITION p_marketing VALUES ('Marketing'),
    PARTITION p_hr VALUES ('HR')
);
```

   - Партиционирование по хешу (Hash Partitioning): Разделение данных на основе хеш-функции.

```SQL
CREATE TABLE orders (
    id INT,
    customer_id INT
)
PARTITION BY HASH (customer_id) PARTITIONS 4;
```


   - Партиционирование по комбинации (Composite Partitioning): Использует более одного метода партиционирования.

```SQL
CREATE TABLE transactions (
    id INT,
    amount DECIMAL(10, 2),
    transaction_date DATE
)
PARTITION BY RANGE (YEAR(transaction_date))
SUBPARTITION BY HASH (amount) (
    PARTITION p2020 VALUES LESS THAN (2021) (
        SUBPARTITION s1,
        SUBPARTITION s2
    ),
    PARTITION p2021 VALUES LESS THAN (2022) (
        SUBPARTITION s3,
        SUBPARTITION s4
    )
);
```


▎**2. Управление партициями**

   - Добавление партиций:

```SQL
ALTER TABLE sales ADD PARTITION (PARTITION p2022 VALUES LESS THAN (2023));
```

   - Удаление партиций:

```SQL
ALTER TABLE sales DROP PARTITION p2019;
```

   - Просмотр информации о партициях:

```SQL
SELECT * FROM information_schema.partitions WHERE table_name = 'sales';
```

### Нюансы
1. **Выбор столбца для партиционирования**  
    - Важно выбирать правильный столбец для партиционирования, чтобы запросы могли эффективно использовать партиции.
    - Столбцы, часто используемые в условиях фильтрации, являются хорошими кандидатами.

2. **Балансировка нагрузки**  
    - Необходимо следить за тем, чтобы партиции были сбалансированы по размеру и количеству данных.
    - Неравномерные партиции могут привести к снижению производительности, так как серверу придется обрабатывать более крупные партиции дольше.

3. **Ограничения на партиционирование**  
    - В различных СУБД существуют свои ограничения по количеству партиций (например, MySQL ограничивает количество партиций для таблиц до 1024).
    - Некоторые типы индексов или агрегатных функций не могут работать с партиционированными таблицами так же, как с обычными.

4. **Использование индексов**  
    - Создание индексов на партиционированных таблицах может быть сложнее, так как индексы могут быть локальными (только на конкретной партиции) или глобальными (на все партиции).
    - Локальные индексы чаще всего производительнее для операций, затрагивающих отдельные партиции.

5. **Обновление и удаление данных**  
    - Операции обновления и удаления данных могут повлиять на производительность на партиционированных таблицах.
    - Если данные перемещаются между партициями, это может вызвать дополнительные накладные расходы.

6. **Переход к новой партиции**  
    - Нужно продумывать стратегию перехода к новым партициям, например при использовании партиционирования по времени, переход на следующий год может потребовать добавления новой партиции и удаления старой.

7. **Настройки статистики**  
    - Некоторые системы управления базами данных требуют дополнительных настроек статистики для эффективного планирования запросов на партиционированных таблицах.
    - Регулярное обновление статистики поможет поддерживать высокую производительность.

### Список вопросов с собеседования

# Репликация
---
---

### Что такое Репликация
- Репликация в SQL — это процесс копирования и поддержания объектов базы данных (таких как таблицы и их данные) между разными базами данных. Она используется для повышения доступности и надежности данных, а также для горизонтального масштабирования.

### Типы репликации
1. **Синхронная репликация:**
    - В этой модели изменения данных в основной базе данных автоматически копируются в реплицированные базы данных в реальном времени.
    - Достоинство: высокая согласованность данных.
    - Недостаток: возможны задержки при записи данных.

2. **Асинхронная репликация:**
    - Изменения в основной базе данных отправляются в реплицированные базы данных с некоторой задержкой.
    - Достоинство: высокая производительность и меньшая нагрузка на сеть.
    - Недостаток: возможность несоответствия данных между основными и реплицированными базами.

### Направления репликации
1. **Мастер-слейв:**
    - В этой схеме одна база (мастер) принимает записи, а одна или несколько других (слейвы) просто копируют данные.
    - Слейвы могут выполнять операции чтения, что позволяет разгрузить основной сервер.

2. **Мастер-мастера:**
    - В этой модели несколько баз данных могут принимать записи и синхронизироваться друг с другом.
     - Потребляет больше ресурсов, так как необходимо разрешать конфликты между записями.

### Нюансы
1. **Конфликты данных**  
При репликации могут возникать конфликты, особенно в системах с записью на нескольких узлах. Это может быть вызвано:

    - Совместными обновлениями одной и той же записи на разных серверах.
    - Различными временными зонами и местоположениями серверов.

Важно реализовать логику обработки конфликтов, чтобы избежать потери данных.

2. **Производительность**  
Репликация может влиять на производительность как мастера, так и слейва. Нюансы включают:

    - Увеличение нагрузки на сеть: Размещение больших объемов данных между мастером и слейвом может привести к задержкам.
    - Нагрузка на процессор: При асинхронной репликации совпадение данных может потребовать дополнительных ресурсов.

3. **Мониторинг и управление**  
Репликация требует постоянного мониторинга состояния серверов. Следует использовать:

    - Инструменты для отслеживания задержек репликации.
    - Настройки алертов для уведомления о сбоях.

4. **Безопасность**  
Использование безопасных соединений между мастером и слейвом имеет ключевое значение для защиты данных. Нюансы безопасности включают:

    - Шифрование данных во время передачи (например, с использованием SSL).
    - Настройки доступа и аутентификации для пользователей репликации.

5. **Обновления и изменения структуры**  
При изменении структуры базы данных (например, добавлении новых таблиц или изменении столбцов) нужно учитывать, как эти изменения будут реплицироваться. Это может потребовать:

    - Пересоздание публикаций и подписок.
    - Проверку совместимости изменений на слейве.

### Список вопросов с собеседования

# Отпимизация SQL запросов
---
---

### Что такое Отпимизация SQL запросов
Оптимизация SQL запросов — это процесс улучшения эффективности SQL-запросов для достижения:
    - Более быстрого выполнения запросов.
    - Снижения нагрузки на сервер базы данных.
    - Экономии ресурсов системы, таких как память и процессор.
      
### Список команд
1. **EXPLAIN**  
Используйте команду EXPLAIN, чтобы получить информацию о том, как будет выполняться ваш запрос. Это поможет понять, какие индексы используются и как выполняется соединение таблиц. 

    _Пример:_

```SQL
EXPLAIN SELECT column1, column2 FROM table WHERE condition;
```

2. **Индексы**  
Создание индексов для ускорения поиска:

    _Пример:_

```SQL
CREATE INDEX index_name ON table(column);
```

3. **Использование JOIN вместо подзапросов**  
В некоторых случаях правильное использование JOIN может быть более эффективным, чем использование подзапросов:

    _Пример:_

```SQL
SELECT a.column1, b.column2
FROM table_a a
JOIN table_b b ON a.id = b.a_id;
```

4. **Ограничение выборки с помощью LIMIT**  
Если вам нужно только несколько записей, используйте LIMIT для снижения нагрузки на сервер:

    _Пример:_

```SQL
SELECT column1, column2 FROM table WHERE condition LIMIT 10;
```

5. **Удаление лишних данных с помощью WHERE**
Фильтруйте результаты на этапе запроса, чтобы избежать ненужных данных:

    _Пример:_

```SQL
SELECT column1, column2 FROM table WHERE condition;
```

6. **Использование агрегатных функций**
Постарайтесь использовать агрегатные функции, чтобы обрабатывать данные на стороне базы данных, а не на клиенте:

    _Пример:_

```SQL
SELECT COUNT(*), AVG(column) FROM table WHERE condition;
```

### Нюансы
1. **Индексы**  
Хотя индексы могут значительно ускорить работу с данными, их чрезмерное использование может замедлить операции вставки и обновления. Нужно находить баланс.

2. **Выбор типов данных**  
Используйте подходящие типы данных для колонок. Например, вместо использования `VARCHAR` для хранения дат лучше использовать тип `DATE`.

3. **Анализ выполнения запросов**  
Регулярно проверяйте, как выполняются ваши запросы с помощью `EXPLAIN` или утилит анализа, чтобы выявлять узкие места.

4. **Условия фильтрации**  
Старайтесь помещать наиболее селективные условия (условия, которые отфильтровывают больше всего данных) в начало `WHERE`-клаузы. Это может улучшить производительность.

5. **Избегание `SELECT *`**  
Избегайте использования `SELECT *`. Лучше указывайте только необходимые колонки, чтобы уменьшить объем передаваемых данных:

```SQL
SELECT column1, column2 FROM table WHERE condition;
```

6. **Правильное использование `JOIN`**  
Понимание типов соединений (`INNER, LEFT, RIGHT`) и их последствий поможет избежать избыточных данных. Оценивайте, какие соединения действительно нужны.

7. **Поддержка индексов**  
Регулярно пересматривайте и обновляйте индексы, особенно после массовых вставок или изменений данных.

8. **Параметризация запросов**  
Используйте параметризированные запросы для предотвращения SQL-инъекций и улучшения производительности за счет повторного использования плана выполнения.

9. **Мониторинг системных ресурсов**  
Следите за использованием ресурсов (памяти, CPU) сервером базы данных и базами данных, что может помочь выявить проблемы с производительностью.

### Список вопросов с собеседования
